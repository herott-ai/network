# 计算机网络
## 第三章
###  2.4编码与调制

1. ![1615903298488](assets/1615903298488.png)
2. ![1615903460701](assets/1615903460701.png)
3. ![1615903646207](assets/1615903646207.png)
4. ![1615903738827](assets/1615903738827.png)
5. ![1615904025275](assets/1615904025275.png)
6. ![1615904193471](assets/1615904193471.png)
7. ![1615904564534](assets/1615904564534.png)
8. ![1615904586196](assets/1615904586196.png)
9. ![1615904619271](assets/1615904619271.png)
10. ![1615904692079](assets/1615904692079.png)
11. ![1615904711025](assets/1615904711025.png)

### 3.1数据链路层概述

1. ![1615945776742](assets/1615945776742.png)
2. ![1615945861093](assets/1615945861093.png)
3. ![1615945983925](assets/1615945983925.png)
4. ![1615946065540](assets/1615946065540.png)
5. ![1615946199553](assets/1615946199553.png)
6. ![1615946334371](assets/1615946334371.png)
7. ![1615946439987](assets/1615946439987.png)
8. ![1615946513753](assets/1615946513753.png)
9. ![1615946547639](assets/1615946547639.png)

### 3.1封装成帧

1. ![1615957280662](assets/1615957280662.png)
2. ![1615957362308](assets/1615957362308.png)
3. ![1615957448351](assets/1615957448351.png)

* **需要说明的是，并不是每一种数据链路层协议的帧都包含有帧定界标志。例如，以太网版本2(V2)的MAC帧格式。在其帧头帧尾中就不包含帧定界标志，那么，接收方又是如何从物理层交付的比特流中提取出一个个的以太网帧呢？**

  **答案是利用前导码和帧间间隔。**

  需要说明的是帧间间隔还有其它作用，后续章节中会提到。

  如下图所示：

  1. ![1615957948266](assets/1615957948266.png)
  2. ![1615957985490](assets/1615957985490.png)

4. ![1615958256450](assets/1615958256450.png)
5. ![1615958407408](assets/1615958407408.png)

* 习题
  1. ![1615958518678](assets/1615958518678.png)

6. ![1615958603832](assets/1615958603832.png)

* 小结：

  ![1615958684546](assets/1615958684546.png)

### 3.3差错检测

1. ![1615959563651](assets/1615959563651.png)
2. ![1615959751755](assets/1615959751755.png)

* 注：由于奇偶校验的漏检率比较高，因此，计算机网络的数据链路层一般不会采用这种检测方法。

3. ![1615960820651](assets/1615960820651.png)
4. ![1615960899025](assets/1615960899025.png)
5. ![1615961054666](assets/1615961054666.png)
6. ![1615961126982](assets/1615961126982.png)
7. ![1615961244305](assets/1615961244305.png)

### 3.4.1可靠传输的基本概念

1. ![1615963132897](assets/1615963132897.png)
2. ![1615963267499](assets/1615963267499.png)
3. ![1615963349194](assets/1615963349194.png)
4. ![1615963506147](assets/1615963506147.png)
5. ![1615963632389](assets/1615963632389.png)

* 小结

  ![1615963680659](assets/1615963680659.png)

### 3.4.2停止等待协议

1. ![1615963831049](assets/1615963831049.png)



### 3.5 点对点协议PPP

* 1. ![1622688028267](assets/1622688028267.png)

  * 请大家想想看，一般的因特网用户是如何接入到因特网的呢？通常都是要通过连接到某个因特网服务提供者ISP。例如中国电信，中国联通，中国移动这三大运营商才能接入因特网。这些ISP已经从因特网管理机构申请到了一批IP地址。用户计算机只有获取到ISP所分配的合法IP地址后，才能成为因特网上的主机。用户计算机与ISP进行通信时，所使用的数据链路层协议通常就是PPP协议。这里需要说明的是，在1999年公布的在以太网上运行的PPP协议，即PPP over Ethernet，简称为PPPoE。它使得ISP可以通过DSL，电路调制解调器，以太网网等宽带接入技术以以太网接口的形式为用户提供接入服务。
  * 另外，点对点协议ppp也广泛应用于广域网路由器之间的专用线路。

  2. ![1622688153039](assets/1622688153039.png)
  3. ![1622688603395](assets/1622688603395.png)

  * 从网络体系结构的角度看，PPP是数据链路层的协议。它将上层交付下来的协议数据单元封装成PPP帧。为了支持不同的网络层协议，PPP协议包含了一套网络控制协议NCPs，其中的每一个协议支持不同的网络层协议。例如TCP/IP中的IP，Novell Netware网络操作系统中的IPX，苹果公司的AppleTalk等。链路控制协议LCP用于建立、配置以及测试数据链路的连接。PPP协议能够在多种类型的点对点链路上运行。例如，面向字节的异步链路，面相比特的同步链路。

  *****

  4. ![1622688999561](assets/1622688999561.png)

  ****

  5. 


### 3.7MAC地址

* MAC地址(作用于数据链路层的帧转发)、IP地址以及ARP协议

  * **==MAC地址是以太网的MAC子层所使用的地址==**;**==（数据链路层）==**
  
* IP地址是TCP/IP体系结构网际层所使用的地址;
  * ARP协议属于TCP/IP体系结构的网际层，其作用是已知设备所分配到的IP地址，使用ARP协议可以通过该IP地址获取到设备的MAC地址;
  * 尽管IP地址和ARP协议属于TCP/IP体系结构的网际层(而不属于数据链路层)，但是它们与MAC地址存在一定的关系，并且我们日常的网络应用都离不开MAC地址、IP地址以及ARP协议。因此，我们将这三者放在一起讨论。
  * ![1617111208080](assets/1617111208080.png)
  
* 1. ![1622692393183](assets/1622692393183.png)

  * 如图所示，两台主机通过一条链路通信。很显然，它们不需要使用地址就可以通信，因为连接在信道上的主机只有它们两个。换句话说，使用点对点信道的数据链路层不需要使用地址。**再来看使用共享信道的总线型局域网。总线上的某台主机要给另一台主机发送帧，表示帧的信号通过总线会传送到总线上的其他所有主机**，

  2. ![1622692744582](assets/1622692744582.png)

  * 那么这些主机如何判断该帧是否是发送给自己的呢？很显然，使用广播信道的数据链路层必须使用地址来区分各主机。也就是说，当多个主机连接在同一个广播信道上，要想实现两个主机间的通信，则每个主机都必须有一个唯一的标识，即一个数据链路层地址。如图所示，假设总线上各主机的地址分别用一个同的大写字母来表示。在每个主机发送的帧中，必须携带标识发送主机和接收主机的地址。由于这类地址是用于媒体接入控制的，其英文缩写词为MAC，可以读作MAC，因此这类地址被称为MAC地址。如图所示，这是主机C要发送给主机D的帧，则在帧首部中的目的地址字段应填入主机D的MAC地址，而在源地址字段，应填入主机C自己的MAC地址。**这样，总线上其他各主机收到该帧后，就可以根据`帧首部中`的目的地址字段的值，是否与自己的MAC地址匹配进而丢弃或接受该帧**。

  3. ![1622692874055](assets/1622692874055.png)

  4. ![1622692988207](assets/1622692988207.png)
  
5. ![1622693107213](assets/1622693107213.png)
  
   是对各接口的唯一标识，而不是对各设备的唯一标识。

****

  ### IEEE 802局域网的MAC地址格式

  1. ![1623585517273](assets/1623585517273.png)

  * **它由==48个比特==构成，每==8个比特为1个字节==，从左至右依次为第一字节到第六字节。前三个字节是组==织唯一标识符OUI==。==生成网络设备的厂商==需要向IEEE的注册管理机构==申请一个或多个OUI==。后三个字节是==获得OUI的厂商可自行随意分配的==。这种地址标识符称为==扩展的唯一标识符EUI==，对于48比特的MAC地址，可称为EUI-48。MAC地址的标准表示方法是==将每4个比特写成一个大写的十六进制的字符，共12个字符==。将每==两个字符分为一组，共6组，组之间用短线连接==。例如，这是Windows系统中的表示方法。**也可以将短线更改为冒号。例如，这是Linux系统，苹果系统，安卓系统中的表示方法。还可以将4个字符分为一组，共三组，组之间用点连接。例如，这是Packet Tracer仿真软件中的表示方法。

***

  2. ![1623585732809](assets/1623585732809.png)

  * 如何在各种系统上查看设备所拥有的MAC地址，大家可自行在网上搜索。另外，我们可以在IEEE的官方网站查看已分配的组织唯一标识符OUI。这是具体的网址。

  3. ![1623585898334](assets/1623585898334.png)

  * **如果我们知道设备的mac地址，而不知道该设备的厂商信息，可以通过设备的MaC地址来查询，有很多网站都提供这样的免费查询服务。例如，在该网站，输入设备的MAC地址后，就可以查出设备的厂商信息**。

****

  4. ![1623587089285](assets/1623587089285.png)

  * MAC地址第一字节的b0位取0时，表示该地址是单播地址;取1时，**==表示该地址是多播地址，又称为组播地址==**。MAC地址第一字节的b1位取0时，表示该地址是全球管理的，也就是全球唯一的;取1时，表示该地址是本地管理的。根据上面的规定，我们来填写下表。
  * 全球管理的单播地址是厂商生产网络设备时给设备的各网络接口固话的MAC地址。
  * 全球管理的多播地址是标准网络设备所应支持的多播地址，用于特定功能，例如交换机生成树协议所需要的多播地址。
  * 本地管理的单播地址，由网络管理员，这种类型的地址，会覆盖网络接口的全球管理单播地址，也就是它的优先级比较高。
  * 本地管理的多播地址用于用户对主机的软件配置，以表明该主机属于哪些多播组。
  * **需要注意的是，当剩余46比特为全1时，也就是MAC地址的48比特全部为1，16进制形式为全F，就是广播地址**。

  5. ![1623587265360](assets/1623587265360.png)

  * 由于MAC地址由48个比特构成，因此总地址数量为2的48次方个，也就是280万亿个。这四类MAC地址各占总地址空间的四分之一，也就是每种MAC地址有70多万亿个。请大家思考一下，我们每个人一般会拥有几个全球管理的单播MAC地址呢？
  * 台式机，笔记本电脑，平板电脑，智能手机等设备上的以太网接口，wifi接口，蓝牙接口都分配有全球单播的MAC地址。而每台交换机和路由器都拥有多个网络接口，也就拥有多个全球单播的MAC地址。
  * 那么，在我们有生之年是否会看到EUI-48地址空间耗尽呢？
  * 对于使用EUI-48空间的应用程序，IEEE的目标寿命为100年(直到2080)，但是鼓励采用EUI-64作为替代。

****

  6. ![1623587375698](assets/1623587375698.png)

****

  7. ![1623587825193](assets/1623587825193.png)

  * 下面，我们来举例说明单播MAC地址的作用。假设这是一个拥有三台主机的总线型以太网，各主机网卡上固化的全球单播MAC地址如图所示。**假设主机B要给主机C发送单播帧，主机B首先要构建该单播帧，==在帧首部中的目的地址字段填入主机C的MAC地址，源地址字段填入自己的MAC地址，再加上帧首部中的其他字段，数据载荷以及帧尾部就构成了该单播帧==。**

  8. ![1623587933888](assets/1623587933888.png)

  * 主机B将该单播帧发送出去，主机A和C都会收到该单播帧，主机A的网卡发现该单播帧的目的MAC地址与自己的MAC地址不匹配，于是丢弃该帧。主机C的网卡发现该单播帧的目的MAC地址与自己的MAC地址匹配，于是接受该帧，并将该帧交给其上层处理。

***

  9. ![1623588162677](assets/1623588162677.png)

  * 再来看广播MAC地址的作用。假设主机B要发送一个广播帧，主机B首先要构建该广播帧，在帧首部中的目的地址字段填入广播地址，也就是16进制的全F，源地址字段填入自己的MAC地址，再加上帧首部中的其他字段、数据载荷以及帧尾部，就构成了该广播帧。

  10. ![1623588287169](assets/1623588287169.png)

  * 主机B将该广播帧发送出去。主机A和C都会收到该广播帧，发现该帧首部中的目的地址字段的内容是广播地址就知道该帧是广播帧，接受该帧，并将该帧交给上层处理。

***

  11. ![1623588765739](assets/1623588765739.png)

  * **再来看多播MAC地址的作用。假设主机A要==发送多播帧给该多播地址==，将该多播地址的左起第一个字节写成8个比特，==可以看到最低比特位是1，这就表明该地址是多播地址==。这里给大家介绍一个快速判断MAC地址是否是多播地址的方法，也就是如果该位十六进制数不能整除2，==即1，3，5，7，9，B，D，F，则该地址是多播地址==。**

  12. ![1623589094580](assets/1623589094580.png)

  * 假设主机B，C，D支持MAC多播，各用户给自己的主机配置的多播组列表如下所示，可以看到，主机B属于两个多播组，主机C也属于两个多播组，而主机D不属于任何多播组。主机A首先要构建该多播帧，在帧首部中的目的地址字段填入该多播地址，源地址字段填入自己的MAC地址。再加上帧首部中的其他字段，数据载荷以及帧尾部，就构成了该多播帧。

  13. ![1623589445332](assets/1623589445332.png)

  * 机A将该多播帧发送出去。主机B,C,D都会收到该多播帧。主机B发现该多播帧的目的MAC地址在自己的多播组列表中，主机C发现该多播帧的目的MAC地址在自己的多播组列表中，因此主机B和C都会接受该帧，并送交上层处理。**而主机D发现该多播帧的目的MAC地址不在自己的多播组列表中，主机D丢弃该多播帧**。

  14. ![1623589493134](assets/1623589493134.png)

  * 需要提醒大家注意的是，当给主机配置多播组列表进行私有应用时，不得使用公有的标准多播地址，具体可在以下网址查询。

****

  15. ![1623589770911](assets/1623589770911.png)

  * 最后。我们简单介绍一下随机MAC地址的概念，据斯诺登爆料，美国国家安全局一套系统，通过监视电子设备的MAC地址来跟踪城市中每个人的行动。因此，苹果率先在IOS系列设备扫描网络时采用随机MAC地址技术。随后，Win10，安卓6.0，以及内核版本为3.18的Linux系统也开始提供随机MAC地址的功能。目前，大多数移动设备已经采用了随机MAC地址技术。

****

  16. ![1623589805305](assets/1623589805305.png)

### 3.7 IP地址

* 1. ![1623590617002](assets/1623590617002.png)

  * 需要说明的是，IP地址属于网络层的范畴，而非数据链路层的范畴。之所以在数据链路层这一章的讲解中引入IP地址，是因为在我们日常的大多数网络应用中，属于数据链路层的MAC地址和属于网络层的IP地址都在使用。它们之间存在一定的关系，IP地址的相关内容比较多，例如，分类的IP地址，划分子网的IP地址，构造超网的IP地址等。这些内容我们将在网络层这一章详细介绍。本节课，我们主要介绍IP地址的作用。
  * 如图所示，假设这是因特网的一部分。我们给网络N8上的两台主机各分配了一个IP地址，给路由器R4连接该网络的接口也分配了一个IP地址。这三个IP地址的前三个10进制数是相同的，也就是网络N8的编号。而最后一个10进制数各不相同，是网络N8上各主机和路由器接口的编号。换句话说，同一个网络上的各主机路由器的各接口的IP地址的网络号部分应该相同，而主机号部分应该互不相同。又例如，我们给网络N9上的各主机和路由器的接口各分配了一个IP地址，这三个IP地址的前三个十进制数是相同的，也就是网络N9的编号，而最后一个10进制数各不相同，是网络N9上各主机和路由器接口的编号。因特网中不同网络的网络编号必须各不相同，例如在本例中，网络N8的编号为192 168 0，而网络N9的编号为192 168 1。需要提醒大家注意的是，在一个IP地址中，哪部分是网络编号，哪部分是主机编号，并不都和本例相同，我们将在后续网络层这一章进行详细介绍。

  2. ![1623591539880](assets/1623591539880.png)

  * **接下来，从网络体系结构的角度看看==IP地址与MAC地址的封装位置==。我们以5层原理体系结构为例，这是应用层封装好的应用层报文。将其向下交付给运输层，==运输层看不懂也无需看懂应用层报文的结构与内容，我们用黑色表示==，==仅仅给其添加一个运输层首部==。运输层将封装好的协议数据单元向下交付给网络层。==网络层看不懂也无需看懂运输层协议数据单元的结构与内容，仅仅给其添加一个网络层首部==，网络层将封装好的协议数据单元向下交付给数据链路层，==数据链路层看不懂也无需看懂网络层协议数据单元的结构与内容，仅仅给其添加一个数据链路层首部和一个数据链路层尾部==，数据链路层将封装好的协议数据单元向下交付给物理层，==物理层看不懂也无需看懂数据链路层协议数据单元的结构与内容，仅仅将它们看作是比特流，以便将它们转换为相应的电信号发送到传输媒体==。**
  * **由于IP地址属于网络体系结构中网络层的范畴，因此在==网络层首部中应该封装有源IP地址和目的IP地址==，相应地，由于MAC地址属于网络体系结构中数据链路层的范畴，因此，==在数据链路层首部中应该封装有源MAC地址和目的MAC地址==。**
  
  3. ![1623636586584](assets/1623636586584.png)
  
  * 接下来，我们来看看数据包转发过程中IP地址与MAC地址的变化情况。如图所示，为了简单起见，图中各主机和路由器各接口的IP地址和MAC地址用比较简单的标识符来表示，而并未使用实际的IP地址和MAC地址。假设主机H1要给主机H2发送一个数据包。我们从网络体系结构的角度来看看数据包在传输过程中IP地址与MAC地址的变化情况。需要注意的是，主机中有完整的网络体系结构，而路由器的最高层为网络层，它没有网络体系结构中的运输层和应用层。我们所关注的重点是网络层封装IP数据报时，源IP地址和目的IP地址应该填写什么。数据链路层封装帧时，源MAC地址和目的MAC地址应该填写什么。因此，我们忽略网络体系结构中，除网络层和数据链路层外的其他各层，可以想象成各网络层进行水平方向的逻辑通信，各数据链路层进行水平方向的逻辑通信。
  
  4. ![1623636874134](assets/1623636874134.png)
  
  * 主机H1将数据包发送给路由器R1。在网络层封装的IP数据报首部中，源IP地址应填写主机H1的IP地址IP1，目的IP地址应填写主机H2的IP地址IP2，也就是从IP1发送给IP2。而在数据链路层封装的帧首部中，源MAC地址应填写主机H1的MAC地址MAC1，目的MAC地址应填写路由器R1的MAC地址MAC3，也就是从MAC1发送给MAC3。路由器R1将收到的数据包转发给路由器R2。在网络层封装的IP数据报首部中，源IP地址仍然填写主机H1的IP地址IP1，目的IP地址仍然填写主机H2的IP地址IP2，也就是从IP1发送给IP2。而在数据链路层封装的帧首部中，源MAC地址应填写路由器R1的MAC地址MAC4，目的MAC地址应填写路由器R2的MAC地址MAC5，也就是从MAC4发送给MAC5。路由器R2将收到的数据包转发给主机H2，在网络层封装的IP数据报首部中，源IP地址仍然填写主机H1的IP地址IP1，目的IP地址仍然填写主机H2的IP地址IP2，也就是从IP1发送给IP2。而在数据链路层封装的帧首部中，源MAC地址应填写路由器R2的MAC地址MAC6，目的MAC地址应填写主机H2的MAC地址MAC2，也就是从MAC6发送给MAC2。
  
  5. ![1623636942475](assets/1623636942475.png)
  
  * 通过本例可以看出:
  
  ******
  
  6. ![1623637074073](assets/1623637074073.png)
  7. ![1623637144852](assets/1623637144852.png)
  
  * 对于本例，主机H1，路由器R1和R2都存在一个共同的问题:那就是知道IP地址，但不知道其相应的MAC地址。如何通过IP地址找出其相应的MAC地址，这是我们下节课将要介绍的地址解析协议ARP所要实现的功能。
  
  ****
  
  #### 习题
  
  1. ![1623637375662](assets/1623637375662.png)
  
  #### 小结
  
  1. ![1623637432558](assets/1623637432558.png)

### 3.7 ARP协议

* 1. ![1623637584893](assets/1623637584893.png)

  * 这是一个**共享总线型**的以太网。为了简单起见，我们只画出了该网络中的三台主机。各主机所配置的IP地址和其网卡上固化的MAC地址如图所示。**假设主机B要给主机C发送数据包。主机B知道主机C的IP地址，但不知道它的MAC地址。==因此，主机B的数据链路层外封装MAC帧时，就无法填写目的MAC地址字段，进而也就无法构建出要发送的MAC帧==。**

  2. ![1623637667067](assets/1623637667067.png)

  * 实际上，**==每台主机都会有一个ARP高速缓存表==**。例如，这是主机B的ARP高速缓存表。**ARP高速缓存表中，记录有`IP地址`和`MAC地址`的对应关系**。例如，这是主机B之前获取到的主机A的IP地址与MAC地址的对应关系。**注意是动态获取到的。**

  3. ![1623637752755](assets/1623637752755.png)

  * **在本例中，当主机B要给主机C发送数据包时，==会首先在自己的ARP高速缓存表中，查找主机C的IP地址所对应的MAC地址==，但未找到。**

  4. ![1623637958446](assets/1623637958446.png)

  * 因此，主机B需要发送`ARP请求报文`来获取主机C的MAC地址。ARP请求报文的内容是:"**我的IP地址为192.168.0.2，我的MAC地址为00-E0-F9-A3-43-77，我想知道`IP地址为192.168.0.2`的主机的MAC地址**"。需要说明的是，为了简单起见，这里我们以比较通俗的语言来描述ARP请求报文的内容，但实际上，ARP请求报文有其具体的格式。另外，需要大家注意的是，**==ARP请求报文被封装在MAC帧中发送，目的地址为广播地址==**。**主机B发送封装有ARP请求报文的==广播帧==，总线上的其他主机都能收到该广播帧，主机A的网卡收到该广播帧后，将其送交上层处理**。上层的ARP进程解析ARP请求报文，发现所询问的IP地址不是自己的IP地址，因此不予理会。**主机C的网卡收到该广播帧后，将其送交上层处理。上层的ARP进程解析ARP请求报文，发现所询问的IP地址正是自己的IP地址，需要进行响应**。

  5. ![1623638066727](assets/1623638066727.png)

  * 主机C首先将ARP请求报文中所携带的**==主机B的IP地址与MAC地址记录到自己的ARP高速缓存表中==**，然后给主机B发送ARP响应报文，以告知自己的MAC地址。

  6. ![1623638195651](assets/1623638195651.png)

  * ARP响应报文的内容是，`"我的IP地址是192.168.0.3，我的MAC地址为00-0C-CF-B8_4A-82"`。需要注意的是，**ARP响应报文被封装在MAC帧中发送，目的地址为主机B的MAC地址**。**==主机C给主机B发送封装有ARP响应报文的单播帧，总线上的其他主机都能收到该单播帧，主机A的网卡收到该单播帧后，发现其目的MAC地址与自己的MAC地址不匹配，直接丢弃该帧。主机B的网卡收发该单播帧后，发现其目的MAC地址就是自己的MAC地址，将其交付上层处理。==**

  7. ![1623638386360](assets/1623638386360.png)

  * 上层的ARP进程解析ARP响应报文，**==将其所包含的主机C的IP地址与MAC地址记录到自己的ARP高速缓存表中==**，如图所示。主机B现在可以给主机C发送之前想发送的数据包了。

  ***

  8. ![1623638509524](assets/1623638509524.png)

  * ARP高速缓存表中的每一条记录，都有其类型。类型分为`动态`和`静态`两种。动态类型是指记录是主机自动获取到的，其生命周期默认为两分钟。当生命周期结束时，该记录将自动删除。这样做的原因是，**==IP地址与MAC地址的对应关系并不是永久性的。例如当主机的网卡坏了，更换新的网卡后，主机的IP地址并没有改变，但主机的MAC地址改变了。静态类型是指记录是用户或网络维护人员手工配置的，不同操作系统下的生命周期不同。例如，系统重启后不存在，或在系统重启后依然有效。==**

  ****

  9. ![1623638584987](assets/1623638584987.png)

  * 接下来，请大家思考一下，在下图所示的网络拓扑中，主机H1是否可以使用ARP协议**==直接==**获取到主机H2的MAC地址？回答是否定的。**==ARP协议只能在一段链路或一个网络上使用，而不能跨网络使用。对于本例，ARP协议的使用是逐段链路进行的。==**

  ### 小结

  1. ![1623638687920](assets/1623638687920.png)

  * 需要说明的是，除ARP请求和响应报文外，ARP还有其他类型的报文，例如用于检查IP地址冲突的无故ARP或称免费ARP。另外，**ARP协议没有安全验证机制，存在`ARP欺骗或攻击等`问题**。

### 3.8 集线器与交换机的区别

* 1. ![1622303076754](assets/1622303076754.png)

  * 这是我们之前课程中经常用来举例的**总线型以太网**。它**最初使用粗同轴电缆作为传输媒体，后来演进到使用价格相对便宜的细同轴电缆**。**当初认为这种连接方法既简单又可靠。因为在==那个时代普遍认为有源器件不可靠，而无源的电缆线才是最可靠的==**。**==然而，这种使用无源电缆和大量机械接头的总线型以太网，并不像人们想象的那么可靠。==**

  2. ![1622303679801](assets/1622303679801.png)

  * 后来，以太网发展出来了一种**==使用大规模集成电路可靠性非常高的设备，叫做集线器。并且使用更便宜，更灵活的双绞线作为传输媒体==。**
  * 如图所示。这是一个使用**集线器和双绞线电缆互连了四台主机的星型拓扑以太网**。主机中的**以太网卡**，以及**集线器**的**各接口使用RJ-45插座**，它们**==之间通过双绞线电缆进行连接==**，==**在双绞线(网线)的两端是RJ-45插头，也就是我们熟称的水晶头**==。

  3. ![1622303858627](assets/1622303858627.png)

  * 实践证明，**使用双绞线和集线器，比使用具有大量机械接头的无源电缆要可靠的多。并且价格便宜，使用方便**。因此，**粗缆和细缆以太网早已成为了历史，从市场上消失了。==使用集线器的以太网，虽然物理拓扑是星型的，但在逻辑上仍然是一个总线网。各站共享逻辑上的总线资源==，使用的还是CSMA/CD协议。**
  * **==集线器只工作在物理层，它的每个接口仅简单地转发比特，不进行碰撞检测(由各站的网卡检测);==**
  * **在分析问题时，我们可将集线器简单看作是一条总线。**
  * **集线器**一般都有**少量的容错能力**和**网络管理功能**。例如，**==若网络中某个网卡出了故障，不停地发送帧。==此时，==集线器可以检测到这个问题，在内部断开与出故障网卡的连线==，使整个以太网仍然能正常工作。**

  ****

  4. ![1622304483227](assets/1622304483227.png)

  * 使用集线器(HUB)可以对以太网进行扩展，由于集线器只工作在物理层，所以更具体的说法是:"使用集线器在物理层扩展以太网"。我们来举例说明，假设某学院下设3个系部，每个系部都有一个使用集线器作为互连设备的以太网。这三个以太网相互独立，各自共享自己的总线资源，是三个独立的碰撞域，或称冲突域。例如，一系中的某台主机给另一台主机发送数据帧，由于总线特性，表示该数据帧的信号会传输到一系中的其他各主机。二系中的多台主机同时发送数据帧，由于总线特性，这必然会产生信号碰撞，碰撞后的信号会传输到二系中的各主机。

  5. ![1622304646270](assets/1622304646270.png)

  * 为了使各系部的以太网能够相互通信，可再使用一个集线器将它们互连起来。这样，原来三个独立的以太网，就互连成为了一个更大的以太网，而原来三个独立的碰撞域，就合并成了一个更大的碰撞我。换句话说，形成了一个更大的总线型以太网。
  * 例如，一系中的某台主机给二系中的某台主机发送数据帧，由于总线特性，表示该数据帧的信号会传输到整个网络中的其他各主机。

  ****

  6. ![1622305057439](assets/1622305057439.png)

  * 在集线器之后，发展出了更先进的网络互连设备，也就是以太网交换机。我们先从一个典型的例子，来看看以太网交换机与集线器的区别。使用集线器互连而成的共享总线式以太网上的某个主机，要给另一个主机发送单播帧，该单播帧会通过共享总线传输到总线上的其他各个主机。使用交换机互连而成的交换式以太网上的某个主机要给另一个主机发送单播帧，该单播帧进入交换机后，交换机会将该单播帧转发给目的主机，而不是网络中的其他各个主机。很显然，交换机具有明显的优势。需要说明的是，为了简单起见，本节课所有举例的前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了。

  7. ![1622305440685](assets/1622305440685.png)

  * 以太网交换机通常都有多个接口。每个接口都可以通过双绞线电缆直接与一台主机或另一个以太网交换机相连。一般都工作在全双工方式，也就是发送帧和接收帧可以同时进行。注意:使用集线器的以太网在逻辑上是共享总线的，需要使用CSMA/CD协议来协调各主机争用总线，只能工作在半双工模式，也就是收发帧不能同时进行。

  8. ![1622305899841](assets/1622305899841.png)

  * 假设这是该交换机的帧交换表。主机A给主机B发送数据帧，交换机收到该帧后，在帧交换表中查找该帧的目的MAC地址，也就是主机B的MAC地址，发现应该从接口2转发。

  9. ![1622305949288](assets/1622305949288.png)

  * 于是就从接口2将该帧转发出去。

  11. ![1622306289270](assets/1622306289270.png)

  * 许多以太网交换机对收到的帧采用存储转发方式进行转发。但也有一些交换机采用直通交换方式，直通交换不必先把整个帧先缓存后再进行处理，而是在接收帧的同时，就立即按帧的目的MAC地址决定该帧的转发接口，因而提高了帧的转发速率。一般采用基于硬件的交叉矩阵，这样交换时延就非常小。但直通交换一个缺点就是它不检查帧是否有差错就直接将帧转发出去。

  ****

  12. ![1622306553617](assets/1622306553617.png)
  
  * 我们先来对比主机发送单播帧的情况，对于使用集线器的共享总线型以太网，单播帧会传播到总线上的其他各主机，各主机中的网卡根据帧的目的MAC地址决定是否接受该帧。对于使用交换机的交换式以太网，交换机收到单播帧后，根据帧的目的MAC地址和自身的帧交换表将帧转发给目的主机，而不是网络中的其他各主机。
  
  13. ![1622368061433](assets/1622368061433.png)
  
  * 我们再来对比发送广播帧的情况。对于使用集线器的共享总线型以太网，广播帧会传播到总线上的其他各主机，各主机中的网卡检测到帧的目的MAC地址是广播地址，就接受该该帧。对于使用交换机的交换式以太网，交换机收到广播帧后，检测到帧的目的MAC地址是广播地址，于是从除该帧进入交换机的接口外的其他各接口转发该帧。网络中除源主机外的其他各主机收到广播帧后，接收该广播帧。从本例可以看出:使用集线器的共享总线型以太网中的各主机属于同一个广播域，而使用交换机的交换式以太网中各主机，也属于同一个广播域。因此，对于广播帧的情况，从效果上看并没有什么区别。
  
  ****
  
  14. ![1622368176808](assets/1622368176808.png)
  
  * ![1622368206360](assets/1622368206360.png)
  * ![1622368226458](assets/1622368226458.png)
  * ![1622368281167](assets/1622368281167.png)
  * 我们再来对比网络中的多台主机同时给另一台主机发送单播帧的情况。对于使用集线器的共享总线型以太网，这必然会产生碰撞。遭遇碰撞的帧会传播到总线上的各主机。
  
  15. ![1622368340681](assets/1622368340681.png)
  
  * ![1622368368137](assets/1622368368137.png)
  * 对于使用交换机的交换式以太网，交换机收到多个帧时，会将它们缓存起来，然后逐个转发给目的主机，不会产生碰撞。
  
  ***
  
  16. ![1622368523554](assets/1622368523554.png)
  
  * 接下来，我们来对比使用集线器扩展以太网和使用交换机扩展以太网有什么区别。首先对比发送单播帧的情况。这是仅使用集线器扩展以太网后，发送单播帧的情况。这是仅使用交换机扩展以太网后，发送单播帧的情况。很显然，交换机具有非常明显的优势。
  
  17. ![1622368692293](assets/1622368692293.png)
  
  * 再来对比发送广播帧的情况，这是这是仅使用集线器扩展以太网后，发送广播帧的情况。这是仅使用交换机扩展以太网后，发送广播帧的情况。从效果上看是一样的。可见，不管使用集线器还是交换机来扩展以太网，扩展后的以太网中的各主机都属于同一个广播域。
  
  18. ![1622369187379](assets/1622369187379.png)
  
  * 仅使用集线器扩展的以太网，在逻辑上仍然是共享总线的，并且形成为一个更大的碰撞域。换句话说，参与竞争总线的主机比扩展前的更多了。这是竞争总线并产生碰撞的一个例子，同样的传输任务，在仅使用交换机扩展的以太网就不会产生碰撞。
  
  19. ![1622369310819](assets/1622369310819.png)
  
  * 因此，如果仅仅使用集线器来扩展以太网，不仅会扩大广播域还同时扩大了碰撞域。但是，如果使用交换机将原来各自独立的碰撞域连接起来，只会扩大广播域而不会扩大碰撞域。也就是说，交换机可以隔离碰撞域。
  
  ****
  
  20. ![1622369518075](assets/1622369518075.png)
  
  * 需要说明的是，工作在数据链路层的以太网交换机，其性能远远超过工作在物理层的集线器，而且价格并不贵，这就使得集线器逐渐被市场淘汰，目前很难在市场上再见到集线器了。

### 3.9以太网交换机自学习和转发帧的流程

* 1. ![1622369786864](assets/1622369786864.png)

  * 需要说明的是，目前市场上也有包含网络层部分功能的交换机，称为3层交换机。

  2. ![1622372021293](assets/1622372021293.png)

  * 下面，我们来举例说明以太网交换机自学匀和转发帧的流程。如图所示，相互连接的两台以太网交换机各自连接了三台主机，狗构成了一个交换式以太网。为了简单起见，各主机中网卡上固化的MAC地址仅用一个大写字母表示，各主机互不相同。为了将重点放在以太网交换机自学习和转发帧的流程上，我们假设各主机已经知道了网络中其他各主机的MAC地址。换句话说，不需要首先通过ARP来获取目的主机的MAC地址。

  3. ![1622372309662](assets/1622372309662.png)

  * 假设主机A给主机B发送帧，该帧从交换机1的接口1进入交换机1，交换机1首先进行登记的工作,将该帧的源MAC地址A记录到自己的帧交换表中，将该帧进入自己的接口的接口号1相应地也记录到帧交换表中。上述登记工作就称为交换机的自学习。之后，交换机1对该帧进行转发。该帧的目的MAC地址是B，在帧交换表中查找MAC地址B，

  4. ![1622372406620](assets/1622372406620.png)

  * 找不到。于是对该帧进行盲目地转发，也称为泛洪。也就是从除该帧进入交换机接口外的其他所有接口转发该帧。

  5. ![1622372615977](assets/1622372615977.png)

  * 可以看出，交换机一开始还是比较"笨"的，它还没有足够的知识来明确转发帧，只能进行盲目地转发。主机B的网卡收到该帧后，根据帧的目的MAC地址B就知道这是发送给自己的帧，于是就接受该帧。主机C的网卡收到该帧后，根据帧的目的MAC地址地址B，就知道这不是发送给自己的帧，于是就丢弃该帧。该帧从交换机2的接口2进入交换机2，交换机2首先进行登记的工作，将该帧的源MAC地址A记录到自己的帧交换表中，将该帧进入自己的接口号2相应地也记录到帧交换表中。之后，交换机2对该帧进行转发，该帧的目的MAC地址是B，在帧交换表中查找MAC地址B，找不到。于是对该帧进行盲目地转发。主机D,E,F都会收到该帧，根据帧的目的MAC地址B就知道这不是发送给自己的帧，于是丢弃该帧。

  ****

  5. ![1622373222803](assets/1622373222803.png)

  * 接下来，主机B给主机A发送帧，该帧从交换机1的接口3进入交换机1。交换机1首先进行登记的工作,将该帧的源MAC地址B记录到自己的帧交换表中，将该帧进入自己的接口的接口号3相应地也记录到帧交换表中。之后，交换机1对该帧进行转发，该帧的目的MAC地址是A，在帧交换表中查找MAC地址A，可以找到。于是按照MAC地址A所对应的接口号1从接口1转发该帧。这是明确的转发。主机A的网卡收到该帧后，根据帧的目的MAC地址A就知道这是发送给自己的帧，于是接受该帧。很显然，交换机2不会收到该帧。

  ***

  6. ![1622377052916](assets/1622377052916.png)
  
  * 接下来，主机E给主机A发送帧，该帧从交换机2的接口3进入交换机2，交换机2首先进行登记的工作。之后，交换机2对该帧进行转发。该帧的目的MAC地址是A，在帧交换表中查找MAC地址A，可以找到。于是按照MAC地址A所对应的接口号2从接口2转发该帧。这是明确的转发。该帧从交换机1的接口4进入交换机1。交换机1首先进行登记的工作。之后，交换机1对该帧进行转发。该帧的目的MAC地址是A，在帧交换表中查找MAC地址A，可以找到。于是按照MAC地址A所对应的接口号1从接口1转发该帧,这是明确的转发。主机A的网卡收到该帧后，根据帧的目的MAC地址A就知道这是发送给自己的帧，于是接受该帧。
  
  7. ![1622378626305](assets/1622378626305.png)
  
  * 我们再来看看以太网交换机丢弃帧的情况。为了演示该情况，我们给交换机1的接口1再连接一台主机G，为了简单起见，没有画出集线器。这样主机A，主机G，交换机1的接口1就共享同一条总线。假设主机G主机A发送帧，该帧通过总线进行传输，主机A和交换机的接口1都可以收到。主机A的网卡收到该帧后，根据帧的目的MAC地址A就知道这是发送给自己的帧，于是接受该帧。交换机1收到该帧后，首先进行登记工作。之后，交换机1对该帧进行转发(图中也应该是句号，不是问号，忘记改了)。该帧的目的MAC地址是A，在帧交换表中查找MAC地址A，
  
  8. ![1622379144321](assets/1622379144321.png)
  
  * 可以找到。MAC地址A所对应的接口号是1，但是，该帧正是从接口1进入交换机1的，交换机1不会再从该接口将该帧转发出去，因为这是没有必要的，于是丢弃该帧。很显然，交换机2不会收到该帧。
  
  *****
  
  9. ![1622379488202](assets/1622379488202.png)
  
  * 随着网络中各主机都发送了帧后，网络中的各交换机就可以学习到各主机的MAC地址以及他们与自己的各接口的对应关系。需要注意的是，帧交换表中的每条记录都有自己的有效时间，到期自动删除!请大家想想看，这是为什么呢？好不容易学习来的记录，为什么要到期自动删除呢？这不是多此一举吗？这是因为MAC地址与交换机接口的对应关系并不是永久性的!例如，交换机某接口所连接的主机更换成了另一台主机。又或者主机中的网卡坏了，更换了新的网卡。这些情况都会导致MAC地址与交换机接口的对应关系的改变。
  * 相信大家还记得我们曾经介绍过的ARP高速缓存表，表中的IP地址与MAC地址的对应关系记录也是会定期自动删除的，这是因为IP地址与MAC地址的对应关系也并不是永久性的。
  * 这个所谓的自学习就是记录MAC地址与接口的对应关系。
  
  ****
  
  10. ![1622379737497](assets/1622379737497.png)
  11. ![1622379896579](assets/1622379896579.png)
  12. ![1622380037001](assets/1622380037001.png)
  13. ![1622380179105](assets/1622380179105.png)
  
  ***
  
  14. ![1622380274706](assets/1622380274706.png)

### 3.10 以太网交换机的生成树协议STP

* 1. ![1622381046991](assets/1622381046991.png)

  * 如何提高以太网的可靠性？例如，如图所示的以太网由三台交换机互连而成，每个交换机上都连接有一些主机，为了简单起见，我们只画出了每个交换机上连接的一台主机。如果交换机A与B之间的链路出现了故障，则交换机B上连接的所有主机，既无法与交换机A上连接的所有主机进行通信，也无法与交换机C上连接的所有主机进行通信。

  2. ![1622381151278](assets/1622381151278.png)

  * 如果交换机A与交换机B和交换机C之间的链路都出现了故障。则原来的以太网变成了三个独立的较小的以太网,它们之间无法通信。

  ***

  3. ![1622381357771](assets/1622381357771.png)

  * 相信很多同学已经想到了，可以通过添加冗余链路的方法来提高以太网的可靠性。例如在本例中，我们给交换机B和C之间添加一条冗余链路之后，即使交换机A和B之间的链路出现了故意，整个网络还是可以连通的。

  4. ![1622383940176](assets/1622383940176.png)
  
  * 但是，冗余链路也会带来负面效应，那就是形成网络环路。
  
  5. ![1622385546570](assets/1622385546570.png)
  
  * 但是，冗余链路也会带来负面效应，那就是形成网络环路。如图所示，网络环路会带来一些问题。例如广播风暴。我们来举例说明，假设主机H1发送了一个广播帧，交换机B收到该帧后，将其从自己的其他所有接口转发出去。交换机A收到交换机B转发来的该帧后，将其从自己的其他所有接口转发出去。同样的，交换机C收到交换机B转发来的该帧后，将其从自己的其他所有接口转发出去。
  
  6. ![1622385886328](assets/1622385886328.png)
  
  * 交换机C收到交换机A转发来的该帧后，将其从自己的其他所有接口转发出去。同样的，交换机A收到交换机C转发来的该帧后，将其从自己的其他所有接口转发出去。交换机B收到交换机C转发来的该帧后，将其从自己的其他所有接口转发出去。
  
  7. ![1622386060266](assets/1622386060266.png)
  
  * 同样的，交换机B收到交换机A转发来的该帧后，将其从自己的其他所有接口转发出去。很显然，该广播帧将在各交换机之间反复转发，分别按顺时针和逆时针方向同时兜圈，这就是所谓的广播风暴。广播风暴会大量消耗网络资源，使得网络无法正常转发其他数据帧;也会使主机反复收到广播帧，大量消耗主机资源。还会使交换机的帧交换表震荡(漂移)。
  
  *****
  
  8. ![1622386212138](assets/1622386212138.png)
  
  * 如图所示，这是交换机B的帧交换表，这其各接口的接口号。为了简单起见，假设各主机的名称也可作为其MAC地址。**当交换机B收到主机H1发送的广播帧后，进行登记工作。将==帧的源MAC地址H1==和帧==进入交换机B的接口号1==登记到帧交换表中。==这条记录是正确的==。当交换机B再次收到交换机C转发来的该广播帧后，进行登记工作。将帧的==源MAC地址H1==和帧进入交换机B的接口号2这条错误记录登记到帧交换表中，==并删除原先正确的记录。==**
  
  9. ![1622386450995](assets/1622386450995.png)
  
  * 当交换机B再次收到交换机A转发来的广播帧后，进行登记工作。将帧的==源MAC地址H1==和帧进入交换机B的==接口号3==这条错误记录登记到帧交换表中，并删除原先错误的记录。
  
  10. ![1622386531674](assets/1622386531674.png)
  
  * **当交换机==B再次收到交换机C转发来的该广播帧==后，进行登记工作。将帧的==源MAC地址H1==和帧进入==交换机B的接口号2==这条错误记录登记到帧交换表中，==并删除原先错误的记录==。很显然，有关==MAC地址H1的记录将在这两个错误记录（接口2和3）之间反复震荡==。**
  * 注意，因为是同一个帧在反复横跳，所以源MAC地址一直都是H1。
  
  ***
  
  11. ![1622387525753](assets/1622387525753.png)
  
  * 我们来举例说明，如图所示，为了提高可靠性，5台交换机之间进行了冗余连接，冗余链路不止一条，网络环路也不止一个。为了简单起见，各交换机上连接的主机没有画出。我们用绿色的小圆圈表示交换机的接口状态为正常状态，用橙色的小方块表示交换机的接口状态为阻塞状态，用红色的x表示出现了故障。如果各交换机的各接口都处于正常状态，则会存在多个网络环路。实际上，各交换机之间按照生成树协议中规定的生成树算法交互一些参数后就可以判断出自己应该阻塞自己的哪些接口，例如图中所示。这样就会形成一个逻辑上没有环路的网络。如图所示。当然，这个逻辑上没有环路的网络。一定要确保连通整个网络，否则就没有意义了。当首次连接交换机或网络物理拓扑发生变化时，这有可能是人为改变造成的，也有可能是出现故障造成的，交换机都将进行生成树的重新计算。
  
  12. ![1622387626578](assets/1622387626578.png)
  
  * 例如，假设这段链路出现了故障。相关交换机检测到该故障后，重新计算生成树，决定将自己之前阻塞的接口恢复为正常状态，这样就会形成一个新的逻辑上没有环路的网络。需要说明的是，生成树算法STA已超出本系列课程的教学大纲。对STA有兴趣的同学可参看我们的另一个系列课程《计算机网络简明教程和仿真实验》。
  * 就是tmd最小生成树算法。
  
  ****
  
  13. ![1622387703737](assets/1622387703737.png)

### 3.11.1 虚拟局域网VLAN概述

* 1. ![1622388341629](assets/1622388341629.png)

  * 如图所示，这是一个由多个以太网交换机互连而成的交换式以太网,每个以太网交换机上都连接了多个主机，形成了一个巨大的广播域。然而，巨大的广播域会带来很多弊端。

  2. ![1622388742210](assets/1622388742210.png)

  * 我们来举例说明广播风暴的问题，假设网络中的某个主机要给另一个主机发送一个数据帧。但是在自己的ARP高速缓存表中，无法查到目的主机的MAC地址。于是首先要发送ARP广播请求获取目的主机的MAC地址，该ARP广播请求会传遍整个网络，网络中的其他所有主机都可以收到该广播，这种情况就是所谓的广播风暴。广播风暴会浪费网络资源和网络中各主机的CPU资源。因此，除非应用需求必须要使用广播,否则网络中的主机应尽量不使用广播。

  ***

  3. ![1622388832498](assets/1622388832498.png)

  * 也许有的同学会有这样的想法:“如果网络中只是偶尔出现广播。那还是可以接受的”。但事实上网络中会频繁出现广播信息，目前使用最广泛的TCP/IP协议栈中的很多协议都会使用广播。

  4. ![1622389204706](assets/1622389204706.png)

  * 那么，如何才能将较大的广播域分割成更小的广播域呢?使用路由器就可以隔离广播域。如图所示，这是由两台以太网交换机互连而成的交换式以太网,网络中的各主机同属于一个广播域。

  5. ![1622389312715](assets/1622389312715.png)

  * 使用路由器可以将该广播域分割成两个较小的广播域。路由器工作在网络体系结构第三层，也就是网络层。由于路由器默认情况下不对广播数据包进行转发，因此路由器很自然地就可以隔离广播域。然后，路由器的成本较高，局域网内部全部使用路由器来隔离广播域是不现实的。在这种情况下，虚拟局域网技术应运而生。

  ****

  6. ![1622389771650](assets/1622389771650.png)

  * 如图所示，1楼，2楼，3楼分别有一个局域网，可将它们通过另外一个交换机互连成一个更大的局域网。

  7. ![1622389860409](assets/1622389860409.png)

  * 那么原来每一个局域网成为现在这个局域网的一个网段。网络中的各主机属于同一个广播域。某个主机发送的广播数据包，其他所有主机都可以收到。

  8. ![1622389934233](assets/1622389934233.png)

  * 根据应用需求，我们将该局域网划分为两个VLAN:VLAN1和VLAN2。此后，VLAN1中的广播数据包不会传送到VLAN2，VLAN2中的广播数据包不会传送到VLAN1。也就是说，同一个VLAN内部可以广播通信，不同VLAN内部不能广播通信。那么，如何才能实现VLAN呢？我们将在下节课进行详细讨论。

  ****

  9. ![1622390005911](assets/1622390005911.png)

### 3.11.2 虚拟局域网VLAN实现机制

* 1. 


## 第四章

### 4.1网络层概述

* 1. ![1618554664956](assets/1618554664956.png)

  * 这些异构型网络如果只是需要各自内部通信，那它们只要实现各自的物理层和数据链路层即可。但是，如果要将这些异构型网络互连起来，形成一个更大的互联网，就需要使用网络层互连设备路由器。

  2. ![1618554839888](assets/1618554839888.png)
  3. ![1618554967823](assets/1618554967823.png)

  * 需要说明的是，为了简单起见，有时我们可以不用画出这些网络，而将他们看做是一条链路即可。

* 4. ![1618555186909](assets/1618555186909.png)
  5. ![1618555196940](assets/1618555196940.png)
  *  6. ![1618555240751](assets/1618555240751.png)
     7. ![1618555300798](assets/1618555300798.png)
  7. ![1618555747873](assets/1618555747873.png)
  
  * 如果网络层不对上述传输错误不采取任何措施，则提供的是不可靠传输错误。如果才去错误，并使得接收方能正确接收到发送方所发送的数据包，则提供的是可靠传输服务。不同网络体系结构所提供的服务可能是不同的，例如，==因特网使用的TCP/IP协议体系的网际层，提供的是无连接的，不可靠的数据报服务==。而ATM，帧中继和X.25的网络层，提供的都是面向连接的，可靠的虚电路服务。
  
  8. ![1618555994120](assets/1618555994120.png)
  
  * 这是网络N1上两个路由器接口各自所分配的IP地址，它们的前三个数是相同的，可以看作是它们所在网络的网络编号。而第四个数各不相同，==用于区分这两个不同的路由器接口==。后面的以此类推。
  
  9. ![1618556695678](assets/1618556695678.png)
  
  * 路由器收到数据包后，是依据什么来决定将数据包从自己的哪个接口转发出去的呢？这个问题在我们之前的过程中曾简单介绍过，不知大家是否还记得？没错，==依据的是数据包中的目的地址和路由器中的路由表。==
  
  10. ![1618556912046](assets/1618556912046.png)
  
  * 例如，这是路由器R1的路由表，里面记录着路由器R1所知道的网络，以及数据包要到达这些网络，应该从自己的哪个接口转发。假设R1知道数据包要到达网络N7,下一跳应将其转发给路由器R4。则路由表中应该有这样一条记录。假设R1知道数据包要到达网络N6,下一跳应将其转发给路由器R2。则路由表中应该有这样一条记录。请大家想想看，**刚才是我们假设R1知道这些路由记录，但在实践当中，路由器是如何得出这样的路由记录呢？**
  * 主要有两种方法:==一种是由用户或网络管理员进行人工配置，这种方法只适用于规模较小，且网络拓扑不改变的小型互联网。另一种是实现各种路由选择协议，由路由器执行路由选择协议中所规定的路由选择算法而自动得出路由表中的路由记录，这种方法更适用于规模较大，且网络拓扑经常改变的大型互联网。==
  
  11. ![1618557313688](assets/1618557313688.png)
  12. ![1618557349488](assets/1618557349488.png)

### 4.2网络层提供的两种服务

* **面向连接的虚电路服务**

  1. ![1618557926436](assets/1618557926436.png)

  * 需要说明的是，**虚电路表示这是一条逻辑上的连接，分组都沿着这条逻辑连接按照==存储转发==方式发送。而不是真正建立了一条物理连接**。而采用电路交换的电话通信，则是先建立一条真正的连接。因此分组交换的虚连接与电路交换的连接只是类似，但并不完全一样。

  2. ![1618558009271](assets/1618558009271.png)

* **无连接的数据报服务** ![1618558387381](assets/1618558387381.png)

* 小结

  ![1618558513457](assets/1618558513457.png)



### 4.3.1IPv4地址概述

* 1. ![1618559055531](assets/1618559055531.png)
  2. ![1618559190904](assets/1618559190904.png)
  3. ![1618559267135](assets/1618559267135.png)
  4. ![1618559339801](assets/1618559339801.png)
  5. ![1618559385199](assets/1618559385199.png)



### 4.3.2分类编址的IPv4地址

* 1. ![1618559745678](assets/1618559745678.png)

  * 此处已经很明确的说明了主机号为`全0`的地址是**==网络地址==**，不能分配给主机或路由器的各接口。
  * ​                      主机号为`全1`的地址是**==广播地址==**，不能分配给主机或路由器的各接口。
  * 记住这个规则！

* **`A类`**

* 1. ![1618561680516](assets/1618561680516.png)

  * **网络号可以从0到127，0和127都不可指派。所以第一个**
    **可以指派的网络号为1，最后一个可以指派的网络号为126。**
    **此时取主机号为全0，即可表示该网络(号)的网络地址。**
    **如100.0.0.0表示网络号为100的这个网络的地址。**

    **或者说该网络的网络地址为100.0.0.0**（网络号就是用来区分网络的）
    
    **每个网络（共128个网络，其中网络号为0和127的不指派）**中==可分配的ip地址数量为1600多万个。==

* **`B类`**

* 1. ![1618562484345](assets/1618562484345.png)

* `C类`

  1. ![1618562901145](assets/1618562901145.png)

* 1. ![1618575119994](assets/1618575119994.png)
  2. ![1618575298774](assets/1618575298774.png)
  3. ![1618575459732](assets/1618575459732.png)
  4. ![1618575707124](assets/1618575707124.png)
  5. ![1618575743379](assets/1618575743379.png)

### 4.3.3划分子网的IPv4地址(提到子网掩码)

* 1. ![1618577337399](assets/1618577337399.png)

  * 为什么会有划分子网这样的需求，如图所示，**某单位有一个大型的局域网需要连接到因特网，如果申请一个C类网络地址，其可分配的IP地址数量只有254个，不够使用。因此，该单位申请了一个B类网络地址，其可分配的IP地址数量达到了65534个，给每台计算机和路由器的接口分配一个IP地址后，还有大量的IP地址剩余，这些剩余的IP地址只能由该单位的同一个网络使用，而其他单位的网络不能使用。**

  2. ![1618577484507](assets/1618577484507.png)

  * **随着该单位计算机网络的发展和建设，该单位又新增了一些计算机，并且需要将原来的网络划分为三个独立的网络，我们称其为子网1，子网2，和子网3。假设子网1仍然使用原先申请到的B类网络地址，那么就需要为子网2和子网3各自申请一个网络地址(网络号)。**
  * 为新增网络申请新的网络号会带来以下弊端:
    1. **需要等待时间和花费更多的费用**
    2. 会增加其他路由器中路由表记录的数量
    3. **浪费原有网络中剩余的大量P地址**

  3. ![1618578029657](assets/1618578029657.png)

  * ==如果可以**从IP地址的主机号**部分，**借用一些位作为子网号来区分不同的子网**，就可以**利用原有网络中剩余的大量IP地址，而不用申请新的网络地址**==。例如，对于本例，==我们可以借用16位主机号中的8位作为子网号==。**假设我们给子网1分配的子网号为0，给子网2分配的子网号为1，给子网3分配的子网号为2。之后，就可以给各子网中的主机和路由器接口分配IP地址了。**

  4. ![1618578179737](assets/1618578179737.png)

* 子网掩码

  1. ![1618578320997](assets/1618578320997.png)
  2. ![1618578602404](assets/1618578602404.png)==（重点图）==

  * **当我们从主机号部分借用一些位作为子网号时，IP地址从两级结构的分类IP地址变成了三级结构的划分子网的IP地址**。==我们用连续的比特1来对应网络号和子网号，用连续的比特0来对应主机号。这样就构成了这个划分子网的IP地址的32比特的子网掩码。==

  * 32比特的子网掩码可以表明==分类IP地址的主机号部分被借用了几个比特作为子网号==

  * 子网掩码：
  
  ​		网络号和子网号部分：子网掩码使用连续的比特1来对应`网络号`和`子网号`。
  
    ​		主机号部分：子网掩码使用连续的比特0来对应主机号。

  * ==将`划分子网的IPv4地址`与其相应的子网掩码进行逻辑与运算就可得到`IPv4地址所在子网的网络地址`==。
  
     意思是说我们将现有的这个IP地址与其相应的子网掩码相与就可以得到这个当前IP地址`所在子网的`网络  
  
     地址(**==就是说一与我们就能看出来这个ip地址在哪个子网，因为任意给定一个ip地址，我们都能够看出来它属于A类，B类，还是C类，这样子我们便能够确定出来这个IP地址的网络号有多少位，但是进行与运算之后，我们便能够知道借用了多少位主机号作为子网号，所以就知道了这个IP地址处在哪个子网了==**。
  
     **就是一与网络号和子网号被保留，主机号被清零。就是说子网掩码的1对应网络号和子网号，0对应主机号，这么简单的东西bb一半天**。**==通过借用n位主机号作为网络号，子网数量变为2^n^，就是说原来的一个网络变为了多个网络(子网)，但是相应的，每个子网的可分配的ip地址数量会减少==**。)。注意网络地址是可以通过IP地址直接看出来的。
  
     这里我就是想说在我们手里有一个确切的Ip地址的时候，我们可以用其对应的子网掩码确定出该IP地址所  
  
     在子网的网络地址，甚至进一步，我们还可以把这个网络地址的主机号部分全取0，得到该子网的广播地址
  
     而下面那句话描述的是在有一个网络地址的时候，怎么对其进行子网划分。
  
  * **==注意在进行子网划分时我们是对一个网络地址用一个子网掩码进行划分。==**
  
  3. ![1618579386925](assets/1618579386925.png)
  
  * **该子网掩码中的10进制数128，用来==表示从IP地址的主机号部分借用多少比特来作为子网号==**。我们将其转换为8个二进制比特。==其中只有一个比特1，这就表明从主机号部分借用1个比特作为子网号==。**因此，可划分出的子网数量为2的1次方，也就是2个。**
  
  * **由于原来的8位主机号被借走1位作为子网号，因此主机号还剩下7位，这就是表达式中8减1的原因。**
  
  * 做题规则：注意到子网掩码中255对应的肯定是网络号，所以我们直接不管255对应的。于是我们把子网掩码中不是255的值写成二进制形式，然后将它与题目中给定的网络地址的主机号部分进行按位与操作肯定会得到几个1，考虑到对于一个网络地址的主机号，主机号肯定全为0，那么我们只要把子网掩码中不是255的地方写成二进制，然后找有几个1即可。假设有n个1，那么我们可以划分出的子网数量就为`2^n`。
  
    **注意这个规则的使用范围只是给出一个确定的网络地址(下面有解释，其实给出一个具体的ip地址也是一样的)，和一个确定的子网掩码。要我们给出子网的划分细节时才使用。**
  
  4. ![1618579719967](assets/1618579719967.png)
  5. ![1618580061877](assets/1618580061877.png)
  
  * **这张图注意理解，并不难，别被吓到了**
  * **==注意这是个C类网络地址。主机号占8位==**
  
  6. ![1618812364777](assets/1618812364777.png)
  
     **==注意这是个C类网络地址。主机号占8位==**
  
  7. ![1618812763565](assets/1618812763565.png)
  
  * 这两个10进制数255，其二进制为16个连续的比特1，它们对应ip地址中的网络号部分(**==在子网掩码中，只要看到255，对应的就是网络号部分==**)。而该子网掩码中==后面两个10进制数252和0，用来表示从IP地址的主机号部分借用多少个比特来作为子网号。==我们将其转换为16个二进制比特。我们将IP地址的主机号部分转换成二进制形式。
  
  8. ![1618813325935](assets/1618813325935.png)
  
  * **==然后将子网掩码中连续6个比特1所对应的主机号部分作为子网号==**。将==网络号==和==子网号==**保持不变**，**而将主机号的10个比特全部取0，就可以得到该主机==所在子网==的网络地址**。(**即这个网络地址(180.80.0.0)所对应的网络号(180.80)被划分成了2的6次方个子网号（2^6个子网），这台主机所在的子网(号)是010011。暂且存疑，不是太确定**) （**==现在我确定了这个想法是正确的==**）**==这里很重要啊！！！！==**
  
  * 所以有两种题型：给出一个网络地址(主机号全为0)和子网掩码，要你给定其划分细节。
  
    ​                给出一个ip地址和子网掩码，让你求出子网号，进而求出该主机==所在子网==的网络地址。
  
    ​                **其实我们可以求出更多细节，因为知道了子网号，即有多少位主机号被借用作为了子网号，还知道这是哪类IP地址，所以也能够给出具体的划分细节**。
  
  9. ![1618813645330](assets/1618813645330.png)
  
* **==默认子网掩码的概念==**

  1. ![1618814067804](assets/1618814067804.png)

* 小结

  ![1618814181125](assets/1618814181125.png)

### 4.3.4无分类编址的IPv4地址

* 基本概念及起源

* 1. ![1618815509383](assets/1618815509383.png)

  * 可读作"sider"。**==这个比划分子网使用得更加普遍。==**

  2. ![1618815697154](assets/1618815697154.png)
  3. ![1618816231082](assets/1618816231082.png)

  * 斜线后面的数字为20，表明该IPv4地址的前20个比特为网络前缀，也就是说，所给地址左起第一个字节，第二个字节，==以及第三个字节的前4个比特==，构成20比特的网络前缀，剩余12个比特为主机号。**因此，我们需要将该地址的第三个字节和第四个字节转换成二进制的形式。这样，我们就可以很容易看出20比特的网络前缀和12比特的主机号。将20比特的网络前缀保持不变，12比特的主机号全部取0，就可以得到该地址块的最小地址。**

  4. ![1618816380477](assets/1618816380477.png)
  
* 路由聚合（构造超网）的基本概念

* 1. ![1618816780496](assets/1618816780496.png)

  * 如图所示，路由器R1与5个网络及路由器R2直接相连。路由器R1和R2互为相邻路由器，它们周期性的通告自己所知道的路由信息给对方。请大家思考一下，R1应该将怎样的路由信息通告给R2呢？如果R1将自己直连的这五个网络的路由记录都通告给R2,则R2的路由表会增加5条路由记录。

  2. ![1618817105522](assets/1618817105522.png)

  * ==为了减少路由记录对路由表的占用，能否将这5条路由记录聚合成1条呢？答案是肯定的。其方法是“找共同前缀”，也就是找出这5个目的网络的共同前缀==。这5个目的网络地址的左起前两个字节都是相同的，从==第三个字节开始不同。因此只需将第三个字节转换成二进制形式，这样就可以很容易找出这5个目的网络地址的共同前缀==，共22个比特。

  3. ![1618817574377](assets/1618817574377.png)

  * **`将共同前缀保持不变，而剩余的10个比特全部取0`，然后写成点分10进制形式，放在"/22"的前面。这就是聚合后的地址块。也可以称为超网。**通过本例，我们还可以看出，**网络前缀越长，地址块越小，路由就越具体（这不是显而易见的吗）**。需要说明的是，==若路由器查表转发分组时发现有多条路由可选，则选择网络前缀最长的那条，这称为**最长前缀匹配**，因为这样的路由更具体。==

* 习题

* 1. ![1618817873528](assets/1618817873528.png)
  2. ![1618818099321](assets/1618818099321.png)

* 小结

* ![1618818188531](assets/1618818188531.png)

### 4.3.5IPv4地址的应用规划

* 概念

* 1. ![1618818531164](assets/1618818531164.png)

  * IPv4地址的应用规划:给定一个IPv4地址块，如果将其划分为几个更小的地址块。并将这些地址块分配给互联网中的不同网络，进而可以给各网络中的主机和路由器接口分配IPv4地址。一般有以下两种方法:

*****

* 定长的子网掩码

  2. ![1618818774008](assets/1618818774008.png)
  3. ![1618818867474](assets/1618818867474.png)

  4. ![1618823154737](assets/1618823154737.png)

  * ==我们需要从主机号借用3个比特作为子网号==，这样可划分出的子网数量为2^3^个，==也就是8个，可以满足我们对子网数量的要求==。而每个子网上的地址数量为2^(8－3)^个，==可以满足我们对子网上IP地址数量的要求==。这样就可以得到子网掩码。

  5. ![1618823272253](assets/1618823272253.png)
  6. ![1618823374379](assets/1618823374379.png)
  7. ![1618823492479](assets/1618823492479.png)

  * 网络5只需要4个IP地址，但是给了32个（==当然是包含了该子网的网络地址和广播地址，因为这样才是一个完整的网络呀==），造成了浪费。

*****

* 变长的子网掩码

1. ![1618836335605](assets/1618836335605.png)

* **主机号的位数决定了这个网络（号）有多少个地址。**

2. ![1618836663538](assets/1618836663538.png)
3. ![1618837192944](assets/1618837192944.png)

* **采用变长的子网掩码进行子网划分，可以按需划分出相应数量的子网，每个子网所分配到的IP地址的数量可以不同，尽可能减少了对IP地址的浪费。例如，图中的网络5只需要4个IP地址，我们也非常精确的给他分配了4个IP地址，没有造成IP地址的浪费。**

* 小结

  ![1618837285735](assets/1618837285735.png)

### 4.4IP数据报的发送和转发过程(提到默认网关)

* **分类：1. 主机发送IP数据报，2. 路由器转发IP数据报。**

* 1. ![1618837798911](assets/1618837798911.png)
  2. ![1620626220430](assets/1620626220430.png)

  * **在图中所示的小型互联网中，路由器的接口0直连了一个交换式以太网，接口1也直连了一个交换式以太网。我们给该网络分配了这样的网络地址和子网掩码。给网络中的各个主机和路由器接口也分配了相应的IP地址和子网掩码。**
  
  3. ![1620626504533](assets/1620626504533.png)
  
  * 我们知道，==同一个网络中的主机之间可以直接通信，这属于直接交付。不同网络中的主机之间的通信，需要通过路由器来中转，这属于间接交付==。**那么源主机如何判断出目的主机是否与自己在同一个网络中？我们来举例说明。**
  
  4. ![1620627020012](assets/1620627020012.png)
  
  * 假设主机C要向主机F发送IP数据报，==主机C将自己的IP地址和子网掩码相与，就可以得到主机C所在网络的网络地址。既然主机C要给主机F发送IP数据报，那主机C肯定知道主机F的IP地址，否则就没法发送了==。==**主机C将主机F的IP地址与自己的子网掩码相与，就可得到目的网络的网络地址。该地址与主机C的网络地址不相等，因此，主机C就知道主机F与自己不在同一个网络中**==。**它们之间的通信属于间接交付。主机C需要将IP数据报传输给路由器，由路由器将IP数据报转发给主机F。**
  
  ****
  
  5. ![1620627535108](assets/1620627535108.png)
  
  * **那么，主机C又是如何知道应该把IP数据报交给哪个路由器进行转发呢？**==**实际上，用户为了让本网络中的主机能和其他网络中的主机进行通信，就必须给其指定本网络中的一个路由器，由该路由器帮忙进行转发。`所指定的路由器，也被称为默认网关`，路由就是网关，网关就是路由**==。**对于本例，我们可以将路由器`接口0的IP地址`指定给该接口所直连网络中的各个主机作为默认网关。同理，可将路由器接口1的IP地址指定给该接口所直连网络中的各个主机作为默认网关**。==这样，当本网络中的主机要和其他网络中的主机进行通信时，`会将IP数据报传输给默认网关，由默认网关将IP数据报转发出去`。==
  
  6. ![1620627776339](assets/1620627776339.png)
  
  * **假设本例中的主机A要给主机D发送IP数据报，这属于间接交付。主机A会将该IP数据报传输给自己的默认网关，也就是图中所示的路由器。那么，当路由器收到IP数据报后，又是如何转发的呢？**
  * 1. ==检查lP数据报首部是否出错==:
       **若出错，则直接丢弃该IP数据报并通告源主机。若没有出错，则进行转发**
    2. ==根据`IP数据报的目的地址`在路由表中查找匹配的条目:若找到匹配的条目，则转发给条目中指示的下一跳。`若找不到，则丢弃该lIP数据报并通告源主机`。==
  
  7. ![1620628052598](assets/1620628052598.png)
  
  * 为了简单起见，我们假设本例中的IP数据报首部没有出现差错。路由器取出IP数据报首部各地址字段的值。源地址字段的值为主机A的IP地址，目的地址字段值为主机D的IP地址。接下来，路由器就要对IP数据报进行查表转发了。
  
  8. ![1620628597949](assets/1620628597949.png)
  
  * 这是路由器的路由表，当我们给路由器的接口配置IP地址和子网掩码时，路由器就知道了自己的该接口与哪个网络是直连的。例如在本例中，接口0所直连的网络是192.168.0.0，相应的地址掩码为255.255.255.128，不需要下一跳路由器，因为接口0与该网络是直连的。接口1所直连的网络是192.168.0.128，相应的地址掩码为255.255.255.128，不需要下一跳路由器，因为接口1与该网络是直连的。需要说明的是，路由表中可能还会有其他路由条目，这可以是用户或网络管理员手工配置的静态路由，也可以是路由器使用路由协议自动获取到的动态路由。我们将在后续课程中详细介绍这部分内容，本节课就不再陈述了。接下来，路由器根据IP数据报的目的地址。
  
  9. ![1620629081801](assets/1620629081801.png)
  
  * 接下来，路由器根据IP数据报的目的地址。在自己的路由表中查找匹配的路由条目，逐条检查路由条目。将目的地址与路由条目中的地址掩码相与得到目的网络地址，该目的网络地址与路由条目中的目的网络地址不相同，则这条路由条目不匹配。
  
  10. ![1620629284926](assets/1620629284926.png)
  
  * 再检查下一条路由条目，将目的地址与下一条路由条目中的地址掩码相与，得到目的网络地址，该目的网络地址与路由条目中的目的网络地址相同，则这条路由条目就是匹配的路由条目，按照它的下一跳指示，也就是从接口1转发该IP数据报。
  
  11. ![1620629502613](assets/1620629502613.png)
  
  * 这样，主机D就可以收到路由器转发来的该IP数据报。需要说明的是，我们这里所介绍的路由器查表转发IP数据报的过程，只是为了让同学们理解其最基本的工作原理。在路由器的实际研发过程中，需要设计很好的数据结构以便提高查找速度。
  
  *****
  
  12. ![1620629916409](assets/1620629916409.png)
  
  * 再来看这种情况，假设主机A给本网路上的各设备发送了一个广播IP数据报。在数据报首部中的目的地址字段可以填写的目的地址为192.168.0.127，这是本网络的广播地址，也可以填写255.255.255.255，这是受限的广播地址。该网络中的各设备都会收到该广播IP数据报。但是路由器收到后并不会转发该数据报。也就是说，路由器是隔离广播域的，这是很有必要的。试想一下，如果因特网中数量巨大的路由器，收到广播IP数据报后都进行转发，则会造成巨大的广播风暴，严重浪费因特网资源。
  
  13. ![1620650988095](assets/1620650988095.png)
  
  * 同理，主机A给另外一个网络发送广播IP数据报，在数据报首部中的目的地址字段，填写的目的地址为192.168.0.255，这是网络192.168.0.128的广播地址。主机A将该广播IP数据报传输给路由器，希望由路由器帮其转发，但路由器判断出这是广播IP数据报，不会进行转发。
  
  ****
  
  14. ![1620651228139](assets/1620651228139.png)
  15. ![1620651386876](assets/1620651386876.png)
  16. ![1620651590941](assets/1620651590941.png)
  17. ![1620651593870](assets/1620651593870.png)
  18. ![1620651666648](assets/1620651666648.png)

### 4.5静态路由配置及其可能产生的路由环路问题

* ==静态路由配置==是指**用户**或**网络管理员**使用路由器的相关命令给路由器==人工配置路由表。==
  * **这种人工配置方式简单、开销小**。但不能及时适应网络状态（流量、拓扑)等。一般只在小规模网络中采用。
  * 使用**==静态路由配置可能出现以下导致产生路由环路的错误==**：
    1. **配置错误**
    2. **聚合了不存在的网络**
    3. **网络故障**

* 1. ![1620651796931](assets/1620651796931.png)
  2. ![1620652876638](assets/1620652876638.png)

  * 接下来，我们首先举例说明静态路由配置。**我们采用如图所示的网络拓扑和相应的IP地址配置。这是路由器R1的路由表，路由器R1通过自己的接口0所配置的IP地址和地址掩码，可以自动得出接口0所在的网络。**==由于接口0与该网络直连，则下一跳**不是路由器地址**，而是通过接口0转发IP数据报给该网络中的某个主机，这属于**直接交付**。这条自动得出的路由条目的类型属于**直连路由**==。同理，**R1还可自行得出接口1的直连网络路由条目。**
  * **这是路由器R2的路由表，这是其接口0的直连网络路由条目，这是其接口1的直连网络路由条目。**

  ****

  3. ![1620653022526](assets/1620653022526.png)

  * **假设R1要转发一个IP数据报给该网络中的某个主机(192.168.2.0/24)。**从图中可以看出，R1应该将该IP数据报转发给路由器R2的接口0。**但R1的路由表中并没有关于该目的网络的路由条目。**换句话说，**R1并不知道目的网络的存在**。因此，**我们可以使用路由器的相关配置命令，给R1添加一条到达该目的网络的路由条目**。==这是该目的网络的地址，**下一跳为路由器R2的接口0的地址(10.0.0.2)**，该路由条目是我们**人工配置的静态路由**,所以类型为**静态**。==

  4. ![1620653287885](assets/1620653287885.png)

  * **==假设R2要转发一个IP数据报给该网络(192.168.1.0/24)==**中的某个主机，**从图中可以看出，R2应该将IP数据报转发给路由器R1的接口1。但R2的路由表中并没有关于该目的网络的路由条目**，==因此，我们可以给R2添加一条到达该目的网络的路由条目。这是该目的网络的地址，下一跳为路由器R1的接口1的地址，类型为静态。**以上就是我们举例说明的静态路由配置**。==

  ****
  ##### 默认路由
  5. ![1620654347388](assets/1620654347388.png)
6. ![1620655148016](assets/1620655148016.png)



  7. ![1620655186086](assets/1620655186086.png)

  * ==接下来，我们举例说明默认路由的概念。==**==假设路由器R2的接口2连接到了因特网==**。这是路由器R1的路由表，这是其接口0的直连网络路由条目，这是其接口1的直连网络路由条目，这是我们人工配置的到达该目的网络的静态路由。**假设R1要转发一个IP数据报给因特网中某个网络中的某个主机，从图中可以看出，R1应该将该IP数据报转发给==路由器R2的接口0==**。**由于因特网中包含了众多的网络，==如果我们给R1添加针对这些网络的每一条路由条目，则会给人工配置带来巨大的工作量，并且使R1的路由表变得非常大，降低了查表转发的速度==**。实际上，**对于==`具有相同下一跳`==的==不同目的网络==的路由条目，==我们可以使用一条默认路由条目来替代==**。**==默认路由条目中的目的网络地址为0.0.0.0，地址掩码也为0.0.0.0，其CIDR形式为0.0.0.0/0==**。对于本例，**==默认路由条目中的下一跳，是路由器R2的接口0的地址==。由于默认路由也是由我们人工配置的，因此其类型也是==静态==。在配置了默认路由条目后，我们甚至可以删除这条路由条目。**
  * **==值得注意的是，默认路由是一个网络地址(目的网络)。归属于目的网络那一栏。==**
  * 对于==`具有相同下一跳`==的不同目的网络。意思是到达某些目的网络之前要经过一个相同的路由器，这个路由器即相同的下一跳。

****

  ##### 特定主机路由

8. ![1620656336047](assets/1620656336047.png)
  9. ![1620656378302](assets/1620656378302.png)

  * **==接下来，我们举例说明特定主机路由的概念==**。**有时候，我们可以给路由器==添加针对某个主机的特定主机路由条目==。一般用于网络管理人员对网络的管理和测试**。另外，在需要考虑某种安全问题时也可以采用特定主机路由。假设这是该网络中的某台特定主机，我们可以在R1的路由表中添加一条到达该主机的特定主机路由条目。特定主机路由条目中的目的网络地址为该特定主机的IP地址，地址掩码为255.255.255.255，其CIDR形式为特定主机IP地址/32。对于本例，特定主机路由条目中的下一跳是路由器R2的接口0的地址。由于特定主机路由也是由我们人工配置的，因此其类型也是静态。可以看出，特定主机路由的目的网络前缀最长，路由最具体。默认路由的目的网络网络前缀最短，路由最模糊。当路由器查表转发IP数据报时，若有多条路由条目可选，则采用"最长前缀匹配的原则"。选用目的网络前缀最长的那个路由条目进行转发。

*****

  10. ![1620656607048](assets/1620656607048.png)

  * 接下来，我们举例说明静态路由配置错误可能导致的路由环路问题。如图所示，这是各路由器自动得出的直连网络。这是我们给各路由器人工配置的静态路由。

  11. ![1620884780222](assets/1620884780222.png)

  * 它表明，R2要转发IP数据报到该网络，下一跳应该转发给R1的接口1。

  12. ![1620884904554](assets/1620884904554.png)

  * 假设我们将下一跳错误地配置成了该地址，也就是错误的指向了R3的接口0，则当R2要转发IP数据报到该网络时，下一跳会错误的转发给路由器R3的接口0

  13. ![1620885015853](assets/1620885015853.png)

  * R3收到该IP数据报后，进行查表转发，找到了匹配的路由条目，下一跳应该转发给该地址，也就是转发给R2的接口1。

  14. ![1620885234495](assets/1620885234495.png)

  * R2收到该IP数据报后，进行查表转发，找到了匹配的路由条目，下一跳应该转发给该地址，也就是转发给R3的接口0。
  * 很显然，由于我们静态路由配置错误，导致R2和R3之间产生了路由环路。为了防止IP数据报在路由环路中永久兜圈，在IP数据报首部设有生存时间TTL字段。IР数据报进入路由器后，TTL字段的值减1。若TTL的值不等于0，则被路由器转发，否则被丢弃。

*****

  15. ![1620885429065](assets/1620885429065.png)

  * 我们再来举例说明，聚合了不存在的网络可能导致的路由环路问题。
  * 这是路由器R1的路由表，这是其自动得出的直连网络这是我们给其人工配置的默认路由，下一跳指向路由器R2的接口0。

  16. ![1620885664511](assets/1620885664511.png)

  * 它是由这两个网络地址聚合而来的，具体方法就是找这两个网络地址的共同前缀，然后将共同前缀保持不变，将剩余比特全部取0，写成点分十进制形式，在其后面写上斜线，斜线后面写上共同前缀的数量。

  17. ![1620885868761](assets/1620885868761.png)

  * 假设R2要转发IP数据报到该网络，进行查表转发，找到了匹配的路由条目，下一跳应该转发给该地址，也就是转发给R1的接口1，R1收到该IP数据报后，进行查表转发，找到了匹配的路由条目，下一跳是通过接口2直接交付。

  18. ![1620886762371](assets/1620886762371.png)

  * 我们再来看看这条聚合路由的细节。它实际上包含了以下4个网络。该网络存在于我们的网络拓扑中，该网络也存在于我们的网络拓扑中，而该网络不存在，该网络也不存在。当R2要转发IP数据报到这个不存在的网络时，进行查表转发找到了匹配的路由条目，下一跳应该转发给该地址，也就是转发给R1的接口1。但对于这个不存在的网络，路由器R2应该不予转发，却错把它转发给了路由器R1。R1收到该IP数据报后，进行查表转发，只能走默认路由，下一跳应该转发给该地址，也就是转发给R2的接口0。很显然，R1和R2之间产生了路由环路。

  19. ![1620886888007](assets/1620886888007.png)

  * 针对这种情况，我们可以在R2的路由表中添加针对所聚合的、不存在的网络的黑洞路由。黑洞路由的下一跳为null0，这是路由器内部的虚拟接口，可以把它形象地看成是一个黑洞，IP数据报进去它后就有去无回了。也就是路由器丢弃了该IP数据报，而不是转发该IP数据报。

  20. ![1620886958373](assets/1620886958373.png)

  * 现在，假设R2要转发IP数据报到这个不存在的网络，进行查表转发，找到了两条可选的路由条目，根据"最长前缀匹配"的原则，

  21. ![1620887027894](assets/1620887027894.png)

  * 将会选择这条到达该不存在网络的黑洞路由。下一跳为虚拟接口null0，因此该IP数据报会进入这个黑洞。

******

  22. ![1620887923965](assets/1620887923965.png)

  * 接下来，我们再来举例说明网络故障可能导致的路由环路问题。假设路由R1检测到其接口0所直连的网络出现了故障而不可达，就会自动在其路由表中删除该直连网络的路由条目。
  * ![1620887987118](assets/1620887987118.png)

  23. ![1620888105341](assets/1620888105341.png)

  * 之后，R2要转发IP数据报到该网络，进行查表转发，找到匹配的路由条目，下一跳应该转发给该地址，也就是转发给R1的接口1，R1收到该IP数据报后，进行查表转发，找不到该IP数据报的目的网络的相关路由条目，只能走默认路由，下一跳应该转发给该地址，也就是转发给R2的接口0。这样，就将该IP数据报错误地转发给了R2。很显然，R1和R2之间产生了路由环路。

  23. ![1620888178484](assets/1620888178484.png)

  * 针对这种情况，我们可以在R1的路由表中，添加针对该直连网络的黑洞路由。

  24. ![1620888302334](assets/1620888302334.png)

  * 这样，当R2要转发该IP数据报到该网络时，进行查表转发，找到匹配的路由条目，下一跳转发给R1的接口1。R1收到该IP数据报后，进行查表转发，找到匹配的路由条目，这是一条黑洞路由，下一跳为虚拟接口null0，因此该IP数据报会进入这个黑洞。

  25. ![1620888392315](assets/1620888392315.png)

  * 假设一段时间后，之前的故障消失了，则R1又自动的得出了其接口0的直连网络的路由条目，并将我们之前人工配置的，针对该直连网络的黑洞路由条目设置为失效状态。

  26. ![1620888486160](assets/1620888486160.png)

*****

  27. ![1620888560745](assets/1620888560745.png)

*****

### 4.6.1路由选择协议概述

* 1. ![1620888737141](assets/1620888737141.png)
  2. ![1620889027352](assets/1620889027352.png)

  * 因特网是全球最大的互联网络。
  * 因特网中的各路由器通过相互间的信息交互，共同完成路由信息的获取和更新。
  * 例如，一个较大的因特网服务提供商就可划分为一个自治系统。在自制系统内部和自制系统外部，采用不同类别的路由选择协议，分别进行路由选择。

  3. ![1620891664587](assets/1620891664587.png)
  
  * 下面，我们来举例说明因特网采用的分层次路由选择协议。假设这是因特网中的很小的一部分，我们可以将这些网络和路由器划归到一个自治系统，而将这些网络划归到另一个自治系统。自治系统之间的路由选择简称为域间路由选择。自治系统内部的路由选择简称为域内路由选择。域间路由选择使用外部网关协议EGP这个类别的路由选择协议。域内路由选择使用内部网关协议IGP这个类别的路由选择协议。需要说明的是，外部网关协议EGP和内部网关协议IGP只是路由选择协议的分类名称，而不是具体的路由选择协议。另外，名称中使用的是"网关"这个名词，是因为在因特网早期的RFC文档中，没有使用"路由器"，而使用的是"网关"这一名词，现在新的RFC文档中又改用"路由器"这一名词。因此，外部网关路由协议EGP可改称为外部路由协议ERP，内部网关协议IGP可改称为内部路由协议IRP。
  * 本课程仍然采用RFC原先采用的名词，以方便大家查看RFC文档。
  * 在一个自治系统内部使用的具体的内部网关协议与因特网中其他自治系统中选用何种内部网关协议无关。例如，在该自治系统内部，使用的内部网关协议为路由信息协议RIP。而在这个自治系统内部使用的内部网关协议为开放式最短路径优先OSPF协议。自治系统之间使用的外部网关协议为边界网关协议BGP。
  
  4. ![1620891872247](assets/1620891872247.png)
  5. ![1620892754388](assets/1620892754388.png)
  
  * 路由选择协议是在路由器上运行的，下面，我们就来看看路由器的基本结构。如图所示，路由器是一种具有多个输入端口和输出端口的专用计算机，其任务是转发分组。整个路由器结构可划分为两大部分:一个是路由选择部分，另一个是分组转发部分。路由选择部分的核心构件是路由选择处理机。它的任务是根据所使用的路由选择协议，周期性地与其他路由器进行路由信息的交互来更新路由表。
  * 分组转发部分由3部分来构成，分别是交换结构，一组输入端口，一组输出端口。
  
  ******
  
  6. ![1620892867326](assets/1620892867326.png)
  7. ![1620892916744](assets/1620892916744.png)
  
  * 信号从某个输入端口进去路由器，物理层将信号转换成比特流，送交数据链路层处理。
  
  8. ![1620893417224](assets/1620893417224.png)
  
  * 数据链路层从比特流中识别出帧，去掉帧头和帧尾后，送交网络层处理，
  
  9. ![1620893515513](assets/1620893515513.png)
  
  * 如果送交网络层的分组是普通待转发的数据分组，则根据分组首部中的目的地址进行查表转发，若找不到匹配的转发条目，则丢弃该分组。
  
  9. ![1620893550468](assets/1620893550468.png)
  
  * 否则，按照匹配条目中所指示的端口进行转发。
  
  9. ![1620893593964](assets/1620893593964.png)
  
  * 网络层更新数据分组首部中某些字段的值，例如将数据分组的生存时间减1，然后送交数据链路层进行封装。
  
  10. ![1620893799530](assets/1620893799530.png)
  
  * 数据链路层将数据分组封装成帧送交物理层处理。
  
  11. ![1620893883537](assets/1620893883537.png)
  
  * 物理层将帧看作是比特流，
  
  11. ![1620893919223](assets/1620893919223.png)
  
  * 将其变换成相应的电信号进行发送。
  
  *****
  
  12. ![1620895124456](assets/1620895124456.png)
  13. ![1620895198451](assets/1620895198451.png)
  14. ![1620895285969](assets/1620895285969.png)
  
  * 如果送交网络层的分组，是路由器之间交换路由信息的路由报文，则把这种分组送交路由选择处理机。路由选择处理机根据分组的内容来更新自己的路由表。
  
  15. ![1620895346061](assets/1620895346061.png)
  16. ![1620895435597](assets/1620895435597.png)
  
  * 路由表一般仅包含从目的网络到下一跳的映射。路由表需要对网络拓扑变化的计算最优化。而转发表是从路由表得出的。转发表的结构应当使查找过程最优化。需要说明的是，我们在之前的静态路由配置的相关课程中，并没有严格区分路由器中的路由表和转发表，这样有助于简化问题的分析。因此，在后续有关路由选择协议的课程中，我们仍然不严格区分路由表和转发表，还是以路由表来表述问题。
  
  17. ![1620895491263](assets/1620895491263.png)
  18. ![1620895521871](assets/1620895521871.png)
  19. ![1620895567330](assets/1620895567330.png)
  20. ![1620895630842](assets/1620895630842.png)
  21. ![1620895663997](assets/1620895663997.png)
  
  * 路由选择处理机除了处理收到的路由报文外，还会周期性地给其他路由器发送自己所知道的路由信息。
  
    上述图片是过程
  
  ******
  
  22. ![1620895778401](assets/1620895778401.png)
  
  * 路由器的各端口还应具有输入缓冲区和输出缓冲区。输入缓冲区用来暂存新进入路由器但还来不及处理的分组。输出缓冲区用来暂存已经处理完毕但还来不及发送的分组。需要说明的是，路由器的端口一般都具有输入和输出的功能，我们图中分别给出输入端口和输出端口，目的在于更好地演示路由器的基本工作过程使同学们更容易理解。
  
  *****
  
  23. ![1620895890538](assets/1620895890538.png)
  
  
  
### 4.6.2路由信息协议RIP的基本工作原理

* 1. ![1620896337446](assets/1620896337446.png)

  * 需要说明的是，有些厂商的路由器，并没有严格按照RIP标准文档的规定来实现RIP，例如思科路由器中的RIP，将路由器到直连网络的距离定义为0，但这并不影响RIP的正常运行。

  2. ![1620896503093](assets/1620896503093.png)
  3. ![1620997959648](assets/1620997959648.png)
4. ![1620998024347](assets/1620998024347.png)
  5. ![1620998542710](assets/1620998542710.png)

  * 如图所示，这是各路由器刚开始工作时各自的路由表。其中包含的路由条目都是到达各自直连网络的信息，其距离都是1。

  6. ![1620998675388](assets/1620998675388.png)

  * 之后，每个路由器仅和相邻路由器周期性地交换并更新路由信息。如图所示，R1和R2互为相邻路由器，R1和R3互为相邻路由器，R2和R3互为相邻路由器，R2和R4互为相邻路由器，R3和R4也互为相邻路由器。相邻路由器之间周期性地交换并更新路由信息。

*****

  7. ![1621001546268](assets/1621001546268.png)

  * 这里讲的是RIP的路由条目的更新规则。
  * 路由器C和D互为相邻路由器，它们之间周期性地交换并更新路由信息。这是路由器C的路由表，其中到达各目的网络的下一跳都记为问号，可以理解为路由器D并不需要关心路由器C的这些内容。这是路由器D的路由表，假设路由器C的RIP更新报文发送周期到了，则路由器C将自己路由表中的相关路由信息封装到RIP更新报文中发送给路由器D。

  8. ![1621001686453](assets/1621001686453.png)
  9. ![1621001713608](assets/1621001713608.png)
  10. ![1621001802072](assets/1621001802072.png)

  * 我们简单的理解为路由器C将自己的路由表发送给了路由器D，路由器D收到后对其进行改造。将到达各目的网络的下一跳都改为C，距离都增加1。这样的操作很容易理解。因为路由器C告诉路由器D，他可以到达这些目的网络，那么路由器D作为C的邻居路由器，当然也就可以通过C来到达这些目的网络，这是比C到达这些目的网络的距离大1。

  11. ![1621001966822](assets/1621001966822.png)

  * 路由器D现在可以根据改造好的路由表来更新自己先前的路由表了。路由器D原来到达网络N2的距离是2，下一跳经过路由器C的转发。现在路由器D知道了，到达网络N2依然经过C的转发，距离变成了5，也就是说，==路由器C与N2之间的网络拓扑发生了变化（比如新增了结点？）。==于是将自己这条路由条目中的距离更新为5。更新路由表的理由可总结为：到达目的网络，相同的下一跳，最新消息，应该更新。

  12. ![1621002090468](assets/1621002090468.png)
  13. ![1621002128132](assets/1621002128132.png)

  * 路由器D原来不知道网络N3的存在，现在路由器D知道了，可以通过路由器C到达网络N3。于是将该路由条目添加到自己的路由表中。更新路由表的理由可总结为发现了新的网络，添加。

****

  14. ![1621002201453](assets/1621002201453.png)
  15. ![1621002253496](assets/1621002253496.png)

  * 路由器D原来到达网络N6的距离是8，下一跳经过路由器F的转发。现在路由器D知道了，到达网络N6如果通过路由器C来转发，则距离可缩短为5。于是将自己这条路由条目中的距离修改为5，下一跳修改为C。更新路由表的理由可总结为到达目的网络，不同的下一跳，新路由有优势，应该更新。

*****

  16. ![1621002339559](assets/1621002339559.png)
  17. ![1621002437869](assets/1621002437869.png)

  * 路由器D原来到达网络N8的距离是4，下一跳经过路由器E的转发。现在路由器D知道了，到达网络N8还可以通过路由器C来转发，距离也为4。于是将该路由条目添加到自己的路由表中。更新路由表的理由可总结为，到达目的网络，不同的下一跳，但距离相等，进行等价负载均衡。

*****

  18. ![1621002553765](assets/1621002553765.png)

  * 路由器D原来到达网络N9的距离是4，下一跳经过路由器F的转发。现在路由器D知道了，到达网络N9如果通过路由器C来转发，则距离扩大为6。于是不使用这条路由条目来更新自己的路由表。不更新路由表的理由可总结为，到达目的网络，不同的下一跳，新路由劣势，不应该更新。

***

  19. ![1621002625295](assets/1621002625295.png)
  20. ![1621002651276](assets/1621002651276.png)

*****

  21. ![1621002760902](assets/1621002760902.png)
  22. ![1621003752926](assets/1621003752926.png)

  * 假设R1到达其直连网络N1的链路出现了故障，当R1检测出该故障后，会将到达N1的路由条目中的距离修改为16，表示N1不可达。并等待RIP更新周期到时后，发送该路由信息给R2。而此时R2的路由表中关于N1的路由条目，仍然是先前通过RIP协议获取到的，也就是到达N1的距离为2，下一跳通过R1转发。假设R2的更新周期先到时，也就是R2的这条路由信息先到达R1，而R1的这条路由信息后到达R2。

  23. ![1621003867616](assets/1621003867616.png)

  * 当R1收到R2的这条路由信息后，就会被该谣言误导，认为可以通过R2到达N1，距离为3。并在自己的RIP更新周期到时后将这条路由信息发送给R2。当R2收到R1的这条路由信息后，被该谣言误导，认为可以通过R1到达N1，距离为4，并在自己的RIP更新周期到时后，将这条路由信息发送给R1。当R1收到R2的这条路由信息后，被该谣言误导，认为可以通过R2到达N1，距离为5。并在自己的RIP更新周期到时后，将这条路由信息发送给R2。很显然，只有当R1和R2的路由表中，到达N1的路由条目中的距离都增加到16后，R1和R2才知道N1不可达，也就是才收敛。

  24. ![1621003934051](assets/1621003934051.png)

  * 在该过程中，R1和R2之间会出现路由环路。时间长大数分钟。

****

  25. ![1621004085071](assets/1621004085071.png)

  * 请注意:使用上述措施后，也不能彻底避免路由环路问题，这是距离向量算法的本质所决定的。

  26. ![1621004207863](assets/1621004207863.png)

### 4.6.3开放最短路径优先OSPF

* 1. ![1621004383841](assets/1621004383841.png)
  2. ![1621004517592](assets/1621004517592.png)
  3. ![1621004570590](assets/1621004570590.png)
  4. ![1621004600890](assets/1621004600890.png)

  *****

  5. ![1621324856093](assets/1621324856093.png)

  * IP数据报首部中的协议号字段的取值为89，来表明IP数据报的数据栽荷为OSPF分组。
* 因此，每个路由器都会建立一张邻居表。例如，这是路由器R1的邻居表。其中的每一个条目，对应记录其各邻居路由器的相关信息。包括邻居ID，接口，以及"死亡"倒计时。例如，R2是R1的一个路由器，为简单起见，邻居ID就记为R2，实践中应填写相应的路由器ID。该邻居路由器与自己的接口1相连，将接口号记为1，死亡倒计时还剩36秒。若在"倒计时"到达0之前，再次收到了来自R2的问候分组，则重新启动针对该邻居路由条目的40秒"死亡"倒计时。否则，当"死亡"倒计时为0时，则判定该邻居路由器不可达。R4是R1的另一个邻居路由器，邻居ID就记为R4。该邻居路由器与自己的接口0相连，将接口号记为0，"死亡"倒计时还剩余18秒。使用OSPF的每个路由器都会产生链路状态通告。
  
*****

6. ![1621325473662](assets/1621325473662.png)

  * ![1621325566751](assets/1621325566751.png)
  * ![1621325571185](assets/1621325571185.png)
  * ![1621325574453](assets/1621325574453.png)
  * 假设N1是路由器R4的直连网络。则R4的链路状态通告应该包含R4与该直连网络的链路状态信息，还应包含其邻居路由器R1的链路状态信息，以及其邻居路由器R3的链路状态信息。
  * 收到链路状态更新分组的路由器，将从自己其他所有接口转发该分组，也就是进行洪泛转发。如图所示
  * 这样，自治系统中每个路由器所发送的封装有链路状态通告的链路状态更新分组，会传递给系统中其他所有路由器。==使用OSPF的每个路由器都有一个链路状态数据库，用于存储链路状态通告。==

  7. ![1621325793888](assets/1621325793888.png)

  * 例如，这是路由器R2的链路状态数据库，其中记录有系统中各路由器的链路状态通告。

****

  8. ![1621326306407](assets/1621326306407.png)

  * 例如，有这样的一个网络拓扑，各链路旁的数字表示代价。通过各路由器洪泛发送封装有自己链路状态通告的链路状态更新分组，各路由器最终会得出相同的链路状态数据库。由链路状态数据库可以得出带权有向图。对该图进行基于Dijkstra的最短路径优先算法，就可以得出以各路由器为根的最短路径。
  * 对于这样一个比较简单的网络拓扑，即使大家不懂得最短路径优先算法，也可以很快找出每个路由器到达其他各路由器的最短路径。但是，如果网络拓扑比较复杂，该项工作对于人类而言就比较复杂了。因此，可用最短路径算法解决。可让路由器执行该算法。

***

  9. ![1621326475451](assets/1621326475451.png)
  10. ![1621327118830](assets/1621327118830.png)

  * 相邻路由器之间周期性发送问候分组，以便建立和维护邻居关系。建立邻居关系后，给邻居路由器发送数据库描述分组。也就是将自己的链路状态数据库中的所有链路状态项目的摘要信息发送给邻居路由器。例如，R1收到R2的数据库描述分组后，发现自己缺少其中的某些链路状态项目，于是就给R2发送链路状态请求分组。R2收到后，将R1所缺少的链路状态项目的详细信息，封装在链路状态更新分组中发送给R1。R1收到后，将这些所缺少的链路状态项目的详细信息添加到自己的链路状态数据库中。并给R2发送链路状态确认分组。需要说明的是，R2也可以向R1请求自己所缺少的链路状态项目的详细信息，这里我们就不再演示该过程了。

  11. ![1621327185362](assets/1621327185362.png)

  * 最终，R1和R2的链路状态数据库将达到一致。也就是链路状态数据库达到同步。

  12. ![1621327275532](assets/1621327275532.png)

  * 每30分钟或链路状态发生变化时，路由器都会发送链路状态更新分组。收到该分组的其他路由器将洪泛转发该分组，并给该路由器发回链路状态确认分组。这又称为新情况下的链路状态数据库同步。

****

13. ![1621345864311](assets/1621345864311.png)

* 当OSPF路由器在多点接入网络中建立邻居关系时，如果不采用其他机制，将会产生大量的多播分组。例如，这5台路由器连接在同一个多点接入网络中，它们周期性地发送问候分组以建立和维护邻居关系。这些路由器中的任意两个路由器都互为邻居关系，如图所示。邻居关系的数量为n(n-1)/2，其中n是路由器的数量。这样，每个路由器要向其他(n-1)个路由器发送问候分组和链路状态更新分组。为了减少所发送分组的数量，OSPF采用选举指定路由器DR和备用的指定路由器BDR的方法。如图所示，假设这两台路由器被分别选举为DR和BDR。

14. ![1621345921879](assets/1621345921879.png)

* 所有的非DR/BDR只与DR/BDR建立邻居关系。

15. ![1621346242222](assets/1621346242222.png)

* 非DR/BDR之间通过DR/BDR交换信息，而必须通过DR/BDR进行交换。若DR出现诃题，则由BDR顶替DR。实现DR和BDR的选举并不复杂，无非就是各路由器之间交换一些选举参数，例如路由器优先级、路由器ID、接口IP地址等。然后根据选举规则选出BR和BDR。这与交换机生成树协议选举根交换机类似。我们就不再陈述了。

*****

16. 

### 4.6.4边界网关协议BGP

* 1. ![1621328256145](assets/1621328256145.png)
  2. ![1621328332568](assets/1621328332568.png)
  3. ![1621328364837](assets/1621328364837.png)

  * 当然。还可以有其它路径。这里就不再一 一列出了

  4. ![1621328474014](assets/1621328474014.png)
  5. ![1621343894232](assets/1621343894232.png)

  ****

  6.  ![1621344085001](assets/1621344085001.png)

  * 一般来说，两个BGP发言人都是通过一个共享网络连接在一起的。而BGP发言人往往就是BGP边界路由器。

  7. ![1621344262332](assets/1621344262332.png)
  8. ![1621344754041](assets/1621344754041.png)

  * 这里，我们给出一个BGP发言人交换路径向量的例子。自治系统AS2的BGP发言人通知主干网的BGP发言人，"要到达网络N1，N2，N3和N4，可经过AS2。"主干网在收到这个通知后，就发出通知，"要到达网络N1，N2。N3和N4。可沿路径(AS1，AS2")。这里的路径(AS1，AS2)称为路径向量。自治系统AS3收到这条路径向量信息后，若AS3自身包含在其中，则不能采用这条路径，否则会兜圈子。

  ****

  9. ![1621345013131](assets/1621345013131.png)

  * 在BGP协议刚刚运行时，BGP的邻站交换整个BGP路由表。但以后只需要在发生变化时更新有变化的部分，这样做对节省网络带宽和减少路由器的处理开销都有好处。

  ****

  10. ![1621345116504](assets/1621345116504.png)
  11. ![1621345191202](assets/1621345191202.png)
  12. ![1621345313006](assets/1621345313006.png)

  * 需要说明的是，BGP协议非常复杂，很多内容都超出了本系列课程的教学目标，因此不再深入探讨

   

### 4.7IPv4数据报的首部格式

* 1. ![1621390870425](assets/1621390870425.png)

  * 为了简单起见，以后我们将IPv4数据报简称为数据报，而不指出版本号。**IP数据报的首部格式及其内容是实现IP协议主要功能的基础，因此，我们我们有必要搞清楚这部分内容。如图所示，这是IP数据报的首部格式，==它由20字节的固定部分和最大40字节的可变部分组成。所谓固定部分，是指每个IP数据报首部都必须包含的部分==，而某些IP数据报的首部，除了包含20字节的固定部分外，还包含一些可选字段来增加IP数据报的功能**。IP数据报的首部常以32个比特为单位进行描述，图中的每一行都由32个比特(也就是4个字节组成)(共5行)，每个小格子称为字段或者域。每个字段或某些字段的组合用来表达IP协议的相关功能。
  
  2. ![1621391282309](assets/1621391282309.png)
  
  * **==我们之前刚刚介绍过首部长度字段是以4字节为单位的。换句话说，IP数据报的首部长度一定是4字节的整数倍。==**
  
  3. ![1621391642041](assets/1621391642041.png)
  
  * **==由于首部中的可选字段的长度从1个字节到40个字节不等，那么，当20字节的固定部分加上1到40个字节长度不等的可变部分会造成首部长度不是4字节整数倍时，`就用取值为全0的填充字段填充相应个字节`。`以确保IP数据报的首部长度是4字节的整数倍`。==**
  
  4. ![1621391851190](assets/1621391851190.png)
  5. ![1621391999493](assets/1621391999493.png)
  
  ******
  
  6. ![1621392186280](assets/1621392186280.png)
  7. ![1621392526334](assets/1621392526334.png)
  
  * **==这是网际层封装出的IP数据报。它将在数据链路层封装成帧。`每一种数据链路层协议都规定了帧的数据载荷的最大长度，称为最大传输单元MTU`。例如，以太网数据链路层规定MTU的值为1500字节。`如果某个IP数据报的总长度超过MTU时，将无法封装成帧，需要将原IP数据报分片为更小的IP数据报。再将各分片IP数据报封装成帧`。==**（考试问题，为什么IP数据报要进行分片？）
  
  8. ![1621392717498](assets/1621392717498.png)
  *****
  9. ![1621394064797](assets/1621394064797.png)
  
  * 共3820字节，以太网的最大传送单元MTU为1500字节。也就是以太网的数据载荷部分最大为1500字节，无法封装3820字节长的IP数据报。因此，需要把该IP数据报分片成几个更小的IP数据报，每个长度不能大于1500字节，然后再将每个分片IP数据报封装成一个以太网帧进行传输。为了更好的描述后续的分片工作，我们将原IP数据报数据载荷部分的每一个字节都编上号。第一个字节编号为0，最后一个字节编号为3799，我们可将原IP数据报的数据载荷分成三个更小的分片。
  * 第一个分片从O号字节到1399号字节,共1400个字节。第二个分片从1400号字节到2799号字节,共1400个字节。第三个分片从2800号字节到3799号字节,共1000个字节。分片结束后，给每个分片重新添加一个首部，使之成为IP数据报。请同学们思考这样一个问题:给各分片添加的首部是否完全相同呢？我们来一起填一下下面这张表格。
  
  10. ![1621394380082](assets/1621394380082.png)
  
  * 由于这是未分片的原IP数据报，因此片偏移为0。
  * 该分片IP数据报数据载荷部分的第一个字节，就是原IP数据报数据载荷部分的第一个字节，因此片偏移字段的取值为0/8。除以8的原因是片偏移字段以8字节为单位。
  
  11. ![1621394835061](assets/1621394835061.png)
  
  * 现在假定分片2的IP数据报经过某个网络时还需要再进行分片。其中一个分片长度为800字节，另一个分片长度为600字节。分片结束后，给每个分片重新添加一个首部，使之成为IP数据报。接下来，请同学们填写该表格。相信大家都可以正确完成。
  
  *****
  
  12. ![1621394984198](assets/1621394984198.png)
  13. ![1621414987336](assets/1621414987336.png)
  
  * 假设采用如图所示的网络拓扑，路由器R1，R2，R3各自的路由表如图所示。为了简单起见，我们只给出了各路由器路由表中的、由人工配置的静态路由条目。例如，路由器R2中的这条静态路由条目，它指出了IP数据报要到达网络N2，下一跳需要转发给路由器R3。
  
  14. ![1621415056455](assets/1621415056455.png)
  
  * 假设我们在人工配置这条静态路由条目时，错将下一跳配置成了R1，这会导致将去往网络N2的IP数据报错误地转发给路由器R1。
  
  15. ![1621415138434](assets/1621415138434.png)
  
  * 我们来看看会出现什么问题:假设某个IP数据报从网络N1发往网络N2。该IP数据报到达R1后，R1进行查表转发，发现了匹配的路由条目，其下一跳指示转发给R2。于是R1将该IP数据报转发给了R2，R2收到该IP数据报后，进行查表转发，发现了匹配的路由条目，其下一跳指示转发给R1。于是R2将该IP数据报又转发回了R1。很显然，形成了路由环路。
  
  16. ![1621415231137](assets/1621415231137.png)
  
  * 如果没有其他措施，IP数据报将在路由环路中永久兜圈。现在，相信大家能够更好的理解，IP数据报首部中生存时间字段的作用了，那就是确保IP数据报不会在网络中永久兜圈。IP数据报每经过一个路由器，其生存时间的值被减1，当减少到0时，IP数据报将被路由器丢弃。
  * 假设采用如图所示的网络拓扑，路由器R1，R2，R3各自的路由表如图所示。为了简单起见，我们只给出了各路由器路由表中的、由人工配置的静态路由条目。例如，路由器R2中的这条静态路由条目，它指出了IP数据报要到达网络N2，下一跳需要转发给路由器R3。假设我们在人工配置这条静态路由条目时，错将下一跳配置成了R1，这会导致将去往网络N2的IP数据报错误地转发给路由器R1。我们来看看会出现什么问题:假设某个IP数据报从网络N1发往网络N2。该IP数据报到达R1后，R1进行查表转发，发现了匹配的路由条目，其下一跳指示转发给R2。于是R1将该IP数据报转发给了R2，R2收到该IP数据报后，进行查表转发，发现了匹配的路由条目，其下一跳指示转发给R1。于是R2将该IP数据报又转发回了R1。很显然，形成了路由环路。如果没有其他措施，IP数据报将在路由环路中永久兜圈。现在，相信大家能够更好的理解，IP数据报首部中生存时间字段的作用了，那就是确保IP数据报不会在网络中永久兜圈。IP数据报每经过一个路由器，其生存时间的值被减1，当减少到0时，IP数据报将被路由器丢弃。
  
  *****
  
  17. ![1621415749121](assets/1621415749121.png)
  
  * 这是一个IP数据报，当首部中协议字段的取值为1时，表明数据部分是ICMP报文，也就是用ICMP协议封装的协议数据单元。
  
  18. ![1621415863313](assets/1621415863313.png)
  
  * 当首部中协议字段的取值为6时，表明数据部分是TCP报文段，也就是用TCP协议封装的协议数据单元。
  
  ****
  
  19. ![1621415922403](assets/1621415922403.png)
  20. ![1621415995729](assets/1621415995729.png)
  
  ****
  
  21. ![1621416050364](assets/1621416050364.png)
  
  ****
  
  ## 练习题
  
  * 1. ![1621416435358](assets/1621416435358.png)
    2. ![1621416493154](assets/1621416493154.png)
    3. ![1621416679748](assets/1621416679748.png)
    4. ![1621416780436](assets/1621416780436.png)
    5. ![1621416810884](assets/1621416810884.png)
    
  ## 小结
  
  * ![1621416861819](assets/1621416861819.png)

### 4.8网际控制报文协议ICMP

* 1. ![1621416991962](assets/1621416991962.png)
  2. ![1621420531521](assets/1621420531521.png)

  * **我们来举例说明，假设主机H1给主机H2发送IP数据报，H1会将IP数据报发送给路由器R1。由R1帮其转发，==若R1的路由表中没有网络N3的记录、默认路由以及主机H2的特定主机路由==，==则R1就不知道如何转发该IP数据报，只能将其丢弃==。并向发送该数据报的==源主机H1==发送ICMP差错报告报文，其类型为==终点不可达==。**

  3. ![1621420689743](assets/1621420689743.png)
  4. ![1621420744824](assets/1621420744824.png)

  ****

  5. ![1621420823813](assets/1621420823813.png)
  6. ![1621421250511](assets/1621421250511.png)
  7. ![1621421288926](assets/1621421288926.png)

  * **某个==生存时间等于2==的IP数据报传输到了路由器R1。==R1将其生存时间减1后结果是1==，这表明该IP数据报的生存时间还没有结束，==R1将其转发出去==。当该数据报传输到路由器R2后，==R2将其生存时间减1后结果是0==，这表明该数据报的生存时间结束了，==R2丢弃该数据报==，并向发送该数据报的源主机H发送CMP差错报告报文，==其类型为时间超过==。另外，==当终点在预先规定的时间内==不能收到一个数据报的==全部数据报片时,就把已收到的数据报片都丢弃，也会向源点发送时间超过报文==。**

  ****

  8. ![1621426934866](assets/1621426934866.png)
  
  * **例如，这是H1发送给H2的IP数据报。假设==该数据报在传输过程中受到了干扰，其首部出现了误码==。**
  
  9. ![1621426999694](assets/1621426999694.png)
  
  
  
  ****
  
  10. ![1621427648191](assets/1621427648191.png)
  
  * 我们来举例说明，假设我们给主机H1指定的默认网关是路由器R1，则H1要发往网络N2的IP数据报都会传输给R1，由其帮忙转发。当R1发现发往N2的数据报的最佳路由不应当经过R1而是应当经过R4时。
  
  11. ![1621427732430](assets/1621427732430.png)
  
  * 就用改变路由报文把这个情况告诉主机。于是，H1就在自己的路由表中添加一个项目:到达N2应经过路由器R4，而不是默认网关R1。之后，H1要发往N2的IP数据报都会传输给R4，由其帮忙转发。
  * 我们来举例说明，假设我们给主机H1指定的默认网关是路由器R1，则H1要发往网络N2的IP数据报都会传输给R1，由其帮忙转发。当R1发现发往N2的数据报的最佳路由不应当经过R1而是应当经过R4时，就用改变路由报文把这个情况告诉主机。于是，H1就在自己的路由表中添加一个项目:到达N2应经过路由器R4，而不是默认网关R1。之后，H1要发往N2的IP数据报都会传输给R4，由其帮忙转发。
  
  ***
  
  12. ![1621427809920](assets/1621427809920.png)
  
  ****
  
  13. ![1621427858547](assets/1621427858547.png)
  
  ****
  
  14. ![1621428046264](assets/1621428046264.png)
  
  15. ![1621428154583](assets/1621428154583.png)
  
      **Groper:咸猪手 Group:触摸，探索**。**==注意，ICMP报文被封装在IP数据报中发送，IP协议是网际层协议，不走运输层很正常啊==**。
  
  16. ![1621428244184](assets/1621428244184.png)
  
  17. ![1621428293697](assets/1621428293697.png)
  
  ### 原理
  
  18. ![1621746257284](assets/1621746257284.png)
  
  * 假设主机H1想知道到达主机H2要经过哪些路由器，H1就给H2发送ICMP回送请求报文，该报文被封装在IP数据报中。IP数据报首部中生存时间字段TTL的值被设置为1。
  
  19. ![1621746348323](assets/1621746348323.png)
  
  * 该IP数据报到达R1后，**==其生存时间减1结果为0==**。R1**丢弃该数据报**并向发送该数据报的源主机H1，**发送ICMP差错报告报文，其类型为时间超过**。这样，**H1就知道了到达H2的路径中的第一个路由器**。
  
  20. ![1621746450905](assets/1621746450905.png)
  
  * H1继续发送下一个封装有ICMP回送请求报文的IP数据报，其首部中生存时间字段TTL的值被设置为2。
  
  21. ![1621746526342](assets/1621746526342.png)
  
  * 经过R1转发后，该数据报的生存时间减少为1。
  
  22. ![1621746593970](assets/1621746593970.png)
  
  * 该IP数据报到达R2后，其生存时间减1，结果为0。R2丢弃该数据报，并向发送该数据报的源主机H1发送ICMP差错报告报文，其类型为时间超过。这样，H1就知道了到达H2的路径中的第二个路由器。
  * 假设主机H1想知道到达主机H2要经过哪些路由器，H1就给H2发送ICMP回送请求报文，该报文被封装在IP数据报中。IP数据报首部中生存时间字段TTL的值被设置为1。该IP数据报到达R1后，其生存时间减1结果为0。R1丢弃该数据报并向发送该数据报的源主机H1，发送ICMP差错报告报文，其类型为时间超过。这样，H1就知道了到达H2的路径中的第一个路由器，H1继续发送下一个封装有ICMP回送请求报文的IP数据报，其首部中生存时间字段TTL的值被设置为2。经过R1转发后，该数据报的生存时间减少为1。该IP数据报到达R2后，其生存时间减1，结果为0。R2丢弃该数据报，并向发送该数据报的源主机H1发送ICMP差错报告报文，其类型为时间超过。这样，H1就知道了到达H2的路径中的第二个路由器。
  
  23. ![1621746684234](assets/1621746684234.png)
  
  * H1继续发送下一个封装有ICMP回送请求报文的IP数据报，其首部中生存时间字段TTL的值被设置为3。
  
  24. ![1621746806542](assets/1621746806542.png)
  
  * 经过R1和R2的转发后，该数据报到达主机H2，其生存时闻减少为1。H2解析该数据报，发现其内部封装的是ICMP送请求报文。于是就给H1发送封装有ICMP回送请求回答报文的IP数据报。这样，H1就知道已经跟踪到路径中的最后一站。也就是目的主机H2。
  * H1继续发送下一个封装有ICMP回送请求报文的IP数据报，其首部中生存时间字段TTL的值被设置为3。经过R1和R2的转发后，该数据报到达主机H2，其生存时闻减少为1。H2解析该数据报，发现其内部封装的是ICMP送请求报文。于是就给H1发送封装有ICMP回送请求回答报文的IP数据报。这样，H1就知道已经跟踪到路径中的最后一站。也就是目的主机H2。
  
  ### 小结
  
  * ![1621746959588](assets/1621746959588.png)

### 4.9 虚拟专用网VPN与网络地址转换NAT

* 1. ![1622442288900](assets/1622442288900.png)

  * 假设这是==**某机构（是同一个机构）**==部门A的局域网，这是机构部门B的局域网，部门A的**局域网**位于北京，部门B的**局域网**位于上海。**那么如何才能让这两个专用网络进行通信呢**？**一种方法是==租用电信公司的通信线路==。这种方法简单方便，但是租金很高。**

  2. ![1622459031041](assets/1622459031041.png)
  
  * 另一种方法是利用**==公用的因特网==**作为**本机构各专用网**之间的**==通信载体==**，**这样的形成专用网又称为虚拟专用网。**
  
  3. ![1622459309302](assets/1622459309302.png)
  
  * 那么**==虚拟专用网中的各主机==**应该分配怎样的IP地址呢？由于IPv4地址的紧缺，一个机构能够申请到的IPv4地址数量往往远小于本机构所拥有的主机数量。因此，**==虚拟专用网中的各主机==**所分配的地址应该是**==无需申请==就可由本机构==自由分配的`专用地址`,==而不是需要申请的、在因特网上使用的公有地址。**
  
  4. ![1622459448803](assets/1622459448803.png)
  
  * 我们可以在因特网数字分配机构IANA的官方网站查看IPv4地址空间中特殊地址的分配方案。这三个地址块中的地址就是**==无需申请的、可自由分配的专用地址，或称私有地址。==**
  
  ****
  
  5. ![1622460333218](assets/1622460333218.png)
  
  * **我们给部门A的专用网分配的私有地址的网络号为10.1.0.0，给部门B的专用网分配的私有地址的网络号为10.2.0.0**。两个专用网中各主机所分配的私有地址如图所示。**需要注意的是，私有地址只能用于一个机构的内部通信，而不能用于和因特网上的主机通信。换句话说，私有地址只能用作本地地址而不能用作全球地址**。**==在因特网中的所有`路由器，对目的地址是私有地址的IP数据报一律不进行转发`。很显然，部门A和B各自至少需要一个路由器具有(在图中也应是具有，不是路由)合法的全球IP地址==**。**这样，它们各自的专用网才能利用公用的因特网进行通信。假设部门A中的这台主机要给部门B中的另一台主机发送数据**。
  
  6. ![1622460367781](assets/1622460367781.png)
  
  * **它会将待发送数据封装成内部IP数据报发送给路由器R1。其首部`源地址`字段的值为部门`A`中该主机的`IP`地址。`目的地址`字段的值为部门`B`中另一台主机的`IP`地址。==R1收到该数据报后，发现其目的网络必须通过因特网才能到达，就将内部IP数据报进行加密，这样就确保了内部IP数据报的安全，`然后重新添加上数据报的首部，封装成为在因特网上发送的外部数据报`==。其首部中`源地址`字段的值为路由器`R1`的==全球地址==,`目的地址`字段的值为路由器`R2`的==全球地址==。**
  * **==简化==**：**==对内部IP数据报进行加密，并将两个私有地址换成两个对应的全球IP地址==**。
  
  7. ![1622460645045](assets/1622460645045.png)
  
  * **路由器R2收到该外部IP数据报后，去掉其首部，将其数据部分进行解密，恢复出原来的内部IP数据报。这样就可以从其首部提取出源地址和目的地址。根据目的地址，将该内部IP数据报发送给相应的主机。==很显然，两个专用网内的主机可以发送的数据报是通过了公用的因特网，但在效果上就好像是在本机构的专用网上传送一样。数据报在因特网中可能要经过多个网络和路由器。但从逻辑上看，R1和R2之间好像是一条直通的点对点链路，因此也被称为`IP隧道技术`==。本例属于同一机构内不同部门的内部网络所构成的`虚拟专用网(就好像是真的用了自己机构的专用网，但实际上还是使用的公用的因特网，所以是虚拟的专用网)`，这又称`内联网VPN`。**
  * ![1622460942169](assets/1622460942169.png)
  
  ****
  
  8. ![1622461089156](assets/1622461089156.png)
  
  * **相信很多同学寒暑假在家中要远程访问校园网内的某些资源时，就使用过远程接入VPN这种技术。**
  
  *****
  
  9. ![1622461274695](assets/1622461274695.png)
  
  * **NAT能`使大量使用内部专用地址的专用网络用户`==共享少量外部全球地址==来访问因特网上的主机和资源。**
  
  9. ![1622461421103](assets/1622461421103.png)
  
  * **我们来举例说明，图中的专用网络使用私有网络号192.168.0.0(==路由器不转发ip数据报到私有地址==)，该网络中各主机的私有地址如图所示。那么使用私有地址的主机如何才能与因特网上使用全球IP地址的主机进行通信呢？**
  
  11. ![1622461519387](assets/1622461519387.png)
  
  * **这需要在专用网络连接到因特网的路由器上安装NAT软件(就是在路由器上装net软件)。`装有NAT软件的路由器叫做NAT路由器`，==它至少有一个有效的外部全球IP地址==。这样，所有使用私有地址的主机在和外界通信时，==都要在NAT路由器上将其私有地址转换成全球IP地址==**。
  
  ****
  
  12. ![1622461589246](assets/1622461589246.png)
  
  * **我们来举例说明，假设使用私有地址的该主机要给因特网上使用全球IP地址的另一台主机发送IP数据报。**
  
  13. ![1622463320657](assets/1622463320657.png)
  
  * **我们来举例说明，假设使用私有地址的该主机要给因特网上使用全球IP地址的另一台主机发送IP数据报。该主机将数据报发送给NAT路由器。数据报首部中源地址字段的值为该主机的私有地址。目的地址字段的值为因特网上另一台主机的全球地址。==NAT路由器从自己的全球IP地址 池 中，为该主机分配一个临时的全球IP地址。并将IP数据报的源地址修改为该地址`172.38.1.5`==。**
  * **然后将==私有地址与全球地址的对应关系==记录在`NAT转换表`(VPN是加密私有IP(对方可以解密得到，并且按同样的方式传回数据)，这个是私有IP与全球IP形成对应)中。之后就可以转发该IP数据报了。==请注意，此时该IP数据报中的源地址和目的地址都是全球IP地址==，**如图所示。
  
  14. ![1622463597392](assets/1622463597392.png)
  
  * **因特网上的这台主机给源主机发回数据报，数据报的源地址和目的地址都是全球IP地址**，如图所示。
  * **NAT路由器收到该IP数据报后，==在NAT转换表中进行查找==，发现该数据报的目的地址所对应的私有地址为192.168.0.2，于是就将该数据报的目的地址修改为192.168.0.2并将其发送给相应的主机。==请注意:此时该IP数据报中的源地址为因特网上那台主机的全球IP地址，而目的地址为专用网中这台主机的私有地址==**。
  
  ****
  
  15. ![1622463925145](assets/1622463925145.png)
  
  * 如图所示，当专用网中的这两台使用私有地址的主机都要给因特网上使用全球地址的另一台主机发送数据报时，在NAT路由器的NAT转换表中就会产生两条记录，分别记录两个私有地址与两个全球地址的对应关系。这种基本转换方法存在这样一个问题:**如果NAT路由器具有N个全球IP地址，那么至多只能有N个内网主机能够==同时==和因特网上的主机通信(这是一个显而易见的问题)**。
  
  16. ![1622464109918](assets/1622464109918.png)
  
  * 如图所示，这是本例中的NAPT路由器，这是它的全球IP地址。这是它的NAPT转换表中的部分内容。实际上现在很多家用路由器都是这种NAPT路由器。由于端口号的概念属于运输层，而我们的课程还没有进行到运输层，因此对该转换表中的内容不再解释。等我们学习了运输层的端口号概念后，相信大家很容易看懂该转换表的内容。现在我还是看不懂。**==它就是加了端口使得标识增多。一个全球ip就能够多个私有ip了，以前是NAT是一一对应的==**。
  
  ****
  
  17. ![1622464246318](assets/1622464246318.png)
  
  * **请大家思考这样一个问题:内网主机与外网主机间的通信是否能由外网主机首先发起？答案是否定的。==如果由外网主机首先发起，那么当NAPT路由器收到来自外网的IP数据报后，在NAPT转换表中找不到相应的记录，也就无法把数据报转发给内网中的主机。因此，使用私有地址的主机不能直接充当因特网服务器==。对于一些点对点网络应用，需要外网主机主动与内网主机进行通信，在通过NAT时也会遇到问题，需要网络应用自己使用一些特殊的`NAT穿越技术`来解决问题**。
  
  18. ![1622464354798](assets/1622464354798.png)
  
  * 另外，由于NAT对外网屏蔽了内网主机的网络地址，因此能为内网主机提供一定的安全保护。还记得我们在上节课中介绍的ICMP协议的典型应用tracert吗？可以看到其中有两个路由器使用了相同的IP地址，这很可能是内网出外网的路由器使用了NAT，并且内网中还有一个使用私有IP地址的路由器。
  
  ****
  
  19. ![1622464437607](assets/1622464437607.png)
  
  vpn是加密(两方都是私有IP)，nat是映射(对方一直是全球ip)。

****

补充一下nat。

**1.为什么出现了NAT?**



IP地址只有32位，最多只有42.9亿个地址，**还要去掉保留地址、组播地址，能用的地址只有36亿左右**，但是当下有数以万亿的主机，没有这么多IP地址怎么办，后面有了IPv6，但是当下IPv4还是主流，利用IPv4怎么满足这么多主机的IP地址呢？**答案就是NAT，NAT技术使公司、机构以及个人产生以及局域网，然后在各个局域网的边界WAN端口使用一个或多个公网的IPv4进行一对多转换。**

**NAT使用基于session的转换规则**

- TCP/UDP ：`私有Host的Ipv4 + port   <======>  NAT公网的Ipv4 + port`
- ICMP ：`私有Host的Ipv4 + sessionID <======>  NAT公网的Ipv4 +  sessionID`



**2.NAT定义**

NAT是 Network Address Translation 网络地址转换的缩写。

NAT是将私有IP地址通过边界路由转换成外网IP地址，在边界路由的**NAT地址转换表**记录下这个转换映射记录，当外部数据返回时，路由使用NAT技术查询NAT转换表，再将目标地址替换成内网用户IP地址。

**RFC1918规定了三块专有的地址，作为私有的内部组网使用：**

A类：10.0.0.0—10.255.255.255      10.0.0.0/8  （10.198.6.252）

B类：**172.16**.0.0—172.31.255.255   172.16.0.0/12

C类：**192.168**.0.0—192.168.255.255 192.168.0.0/16

这三块私有地址本身是可路由的，只是公网上的路由器不会转发这三块私有地址的流量；**当一个公司内部配置了这些私有地址后，内部的计算机在和外网通信时，公司的边界路由会通过NAT或者PAT技术**，将内部的私有地址转换成外网IP，**外部看到的源地址是公司边界路由转换过的公网IP地址**，这在某种意义上也增加了内部网络的安全性。



**3.三种NAT技术**



   假设一种场景，公司对外的有两个公网IP地址是 191.4.4.1/191.4.4.2，有两台主机A和B，局域网地址分别是192.168.1.2和192.168.1.3

**3.1 静态NAT**

​      静态NAT就是一对一映射，内部有多少私有地址需要和外部通信，就要配置多少外网IP地址与其对应，并不节省外网IP，所以一般不用

![image-20220910152921985](assets/image-20220910152921985.png)

**3.2 动态NAT**

​     动态NAT是在路由器上配置一个外网IP地址池，当内部有计算机需要和外部通信时，**==就从地址池里动态的取出一个外网IP，并将他们的对应关系绑定到NAT表中，通信结束后，这个外网IP才被释放，可供其他内部IP地址转换使用==**，这个DHCP租约IP有相似之处。

![image-20220910152959320](assets/image-20220910152959320.png)

**3.3 PAT(port address Translation，端口地址转换，也叫端口地址复用)**

​     这是最常用的NAT技术，也是IPv4能够维持到今天的最重要的原因之一，它提供了一种**多对一(多个私有IP对应一个公网IP)**的方式，**对多个内网IP地址，边界路由可以给他们分配一个外网IP，==利用这个外网IP的不同端口和外部进行通信==**。

![image-20220910153018494](assets/image-20220910153018494.png)

作者：gson
链接：https://zhuanlan.zhihu.com/p/25133143
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。





## 第五章

### 5.1运输层概述

* 1. ![1621490644144](assets/1621490644144.png)

  * 如图所示，**局域网1**上的**主机**与**局域网2上的主机**通过**互连的广域网**进行通信。==网络层的范围是主机到主机。==但**实际上**在==计算机网络中进行通信的真正实体==**是位于通信两端**==主机中的进程==。例如，AP1和AP2是局域网1上这台主机中的、与网络通信相关的两个应用进程。AP3和AP4是局域网2上这台主机中的、与网络通信相关的两个应用进程。AP是应用进程的英文缩写词。

  2. ![1621490720366](assets/1621490720366.png)

  * 如图所示，==运输层的作用范围是应用进程到应用进程，也称为端到端。==接下来，我们从计算机网络体系结构的角度来看运输层。

  3. ![1621490935649](assets/1621490935649.png)

  * 这是通信双方应用层中的应用进程，假设AP1与AP4之间进行基于网络的通信，AP2与AP3之间进行基于网络的通信，==**在运输层使用不同的端口来对应不同的应用进程，**==然后通过**网络层及其下层**来**传输应用层报文**。如图所示
  * **接收方的应用层**，**==通过不同的端口==**将收到的应用层报文**交付给应用层中相应的应用进程**。
  * **需要注意的是**，==这里的端口并不是指看得见、摸得着的物理端口==，而是==**指用来区分不同应用进程的标识符。**==为了简单起见，在学习和研究运输层时，我们**可以简单的认为**，**运输层直接为应用进程间的==逻辑通信==提供服务**。"逻辑通信"的意思是:**运输层之间的通信，==好像是沿水平方向传送数据==，**==但事实上==，==**这两个运输层之间并没有一条水平方向的物理连接。要传送的数据是沿着图中上下多次的虚线方向传送的，**==

  4. ![1621491064810](assets/1621491064810.png)

  * 运输层**向高层用户屏蔽了下面网络核心的细节(**如**网络拓扑、所采用的路由选择协议**等)，它使应用进程看见的==**就好像是**==在两个==**运输层实体之间有一条端到端的逻辑通信信道。**==
    根据**应用需求的不同**，因特网的**==运输层为应用层提供==**了两种不同的运输协议**==，即面向连接的TCP和无连接的UDP==**，这两种协议就是本章要讨论的主要内容。

  5. ![1621491182378](assets/1621491182378.png)

### 5.2 运输层端口号、复用与分用的概念

* 1. ![1621491763580](assets/1621491763580.png)
  
  * **==端口号只是为了标识本机中的某个应用。==**
  
  ****
  
  ***
  
  2. ![1621747384777](assets/1621747384777.png)
  
  * 如图所示，这是收发双方的应用进程。**发送方的某些应用进程**所**发送的不同应用报文**，==**在运输层使用UDP协议进行封装**，这称为**UDP复用**。==
  * 而**另一些应用进程**所**发送的不同的应用报文**，**==在运输层使用TCP协议进行封装==，这称为==TCP复用==**。**==运输层==使用==端口号来区分==不同的应用进程**。**不管是使用运输层的UDP协议封装成的==UDP用户数据报==，还是使用TCP协议封装成的==TCP报文段==，在==网络层==都需要==使用IP协议封装成IP数据报==，这称为==IP复用==。**IP数据报**首部中==协议字段的值==用来表明==IP数据报的数据载荷部分==封装的是==何种协议数据单元==，取值为==6，表示封装的是TCP报文段==，取值为==17，表示封装的是UDP用户数据报==。**
  * 接收方的**==网络层==收到IP数据报后进行==IP分用==**，若IP数据报首部中协议字段的值为17，则把IP数据报的数据载荷部分所封装的UDP用户数据报**上交运输层的UDP**;若协议字段的值为6，则把IP数据报的数据载荷部分所封装的TCP报文段**上交运输层的TCP**。**运输层对UDP用户数据报进行==UDP分用==，对TCP报文段进行==TCP分用==**。**也就是根据==端口号==，将它们==交付给上层相应的应用进程==。**
  
  *******
  
  3. ![1621748226710](assets/1621748226710.png)
  
  * 不管在运输层使用UDP还是TCP协议，**==在网络层都需要使用IP协议==**。**IP数据报==首部中协议字段的值==**表明了IP数据报的==**数据载荷部分封装的是何种协议数据单元**==。
  
  *****
  
  



### 5.3 UDP和TCP的对比

* 1. ![1621497637427](assets/1621497637427.png)

  * TCP/IP体系结构**==应用层中的某些协议==需要使用==运输层的TCP==提供的服务**，而**另一些协议需要**使用==运输层的UDP==提供的服务。

  2. ![1621498037263](assets/1621498037263.png)

  * 如图所示，这是因特网上的两台主机，**它们在运输层使用UDP协议进行通信，纵坐标为时间，使用UDP协议的通信双方，==可以随时发送数据==。**再来看使用TCP协议的情况。使用TCP协议的通信双方，**在进行数据传输之前**，==**必须使用"三报文握手"来建立TCP连接**==，**TCP连接建立成功后才能进行数据传输**。数据传输**结束后**，**==必须使用"四报文挥手"来释放TCP连接。==**"三报文握手"和"四报文挥手"属于TCP的连接管理，其过程比较复杂，我们将在后续课程中专门介绍。**需要注意的是:这是所谓的连接是指逻辑连接关系，而不是物理连接。综上所述，==UDP是无连接的，而TCP是面向连接的==。**

  ****

  3. ![1621500252826](assets/1621500252826.png)
  
  * 这是**某个局域网上**，**==使用UDP协议==**进行通信的四台主机。**其中任何一台主机都可向其他三台主机发送==广播，==**
  
  4. ![1621500298261](assets/1621500298261.png)
  
  * **也可以向某个多播组发送==多播==，**
  
  5. ![1621500372523](assets/1621500372523.png)
  
  * **还可以向某台主机发送==单播==。**
  
  6. ![1621500435020](assets/1621500435020.png)
  
  * 这是某个局域网上，使用UDP协议进行通信的四台主机。其中任何一台主机都可向其他三台主机发送广播，也可以向某个多播组发送多播，还可以向某台主机发送单播。**也就是说，UDP支持单播、多播以及广播。**换句话说，**==UDP支持一对一，一对多，以及一对全的通信。==**
  
  7. ![1621500482494](assets/1621500482494.png)
  
  * 再来看使用TCP协议的情况，==使用TCP协议的通信双方，在进行数据传输之前，必须使用**"三报文握手"**来建立TCP连接，==
  
  8. ![1621500558898](assets/1621500558898.png)
  
  * 再来看使用TCP协议的情况，使用TCP协议的通信双方，在进行数据传输之前，必须使用"三报文握手"来建立TCP连接，TCP连接建立成功后，==通信双方之间**就好像有**一条可靠的通信信道==，**通信双方使用==这条==基于TCP连接的==可靠信道==进行通信。很显然，TCP仅支持单播，也就是一对一的通信。**
  
  ****
  
  ### 两个协议对应用报文的对比
  
  1. ![1621576330938](assets/1621576330938.png)
  
  * 我们来对比这两个协议对应用报文的处理，先来看看使用UDP协议的情况。**发送方的应用进程**将**应用层报文**交付给**==运输层的UDP==**。**UDP==直接给应用层报文添加一个UDP首部==**，使之**成为UDP用户数据报**，然后进行发送。需要说明的是，为了简单起见，我们忽略运输层下面的各层处理。**接收方的UDP收到该UDP用户数据报后，==去掉UDP首部，将应用层报文交付给应用进程==**。也就是说，**UDP对应用进程交下来的报文既不合并也不拆分，==而是保留这些报文的边界==。换句话说，==UDP其面向应用报文的==。**
  
  2. ![1621577760000](assets/1621577760000.png)
  
  * 再看来使用TCP协议的情况，发送方的TCP把**应用进程交付下来的数据块==仅仅==看作是==一连串的、无结构的字节流==。**TCP**并不知道这些待传送的字节流的含义**，**仅将它们编号，并存储在自己的发送缓存中。**TCP根据发送策略，从发送缓存中提取一定数量的字节，构建TCP报文段并发送。接收方的TCP，一方面从所接收到的TCP报文中，取出数据载荷部分并存储在接收缓存中。一方面将接收缓存中的一些字节交付给应用进程。TCP不保证接收方应用进程所收到的数据块与发送方应用进程所发出的数据块具有对应大小的关系。例如，发送方应用进程交给发送方的TCP共10个数据块，但接收方的TCP可能只用了4个数据块就把收到的字节流交付给了上层的应用进程。但接收方应用进程收到的字节流必须和发送方应用进程发出的字节流完全一样。当然，接收方的应用进程必须有能力识别收到的字节流，把它还原成有意义的应用层数据。也就是说，TCP是面向字节流的，这正是TCP实现可靠传输、流量控制、以及拥塞控制的基础。需要说明的是:为了突出示意图的要点，我们只画出了一个方向的数据流。在实际网络中，基于TCP连接的两端，可以同时进行TCP报文段的发送和接收，也就是全双工通信。另外，图中TCP报文段的数据部分只包含了几个字节。实际当中，一个TCP报文段包含上千个字节是很常见的。
  
  ******
  
  1. ![1621577950160](assets/1621577950160.png)
  
  * 再来看下一个对比项，在之前的课程中，我们曾介绍过**TCP/IP体系结构的==网际层向其上层提供的是无连接不可靠的传输服务==**。当**运输层使用UDP协议时**，**==向其上层提供的也是无连接不可靠的传输服务==**。发送方给接收方发送UDP用户数据报，**若传输过程中用户数据报受到干扰而产生误码**。**接收方UDP可以通过该==数据报首部中的校验和字段的值==检查出产生误码的情况**。**==但仅仅丢弃该数据报，其他什么也不做！==**
  * **发送方给接收方发送UDP用户数据报，如果该数据报被因特网中的某个路由器丢弃了，发送方UDP不做任何处理**。因为**==UDP向上层提供的是无连接不可靠的传输服务==**。因此，**对于UDP用户数据报出现误码和丢失等问题，UDP并不关心**，基于UDP的这个特点，**UDP适用于==实时应用==，例如IP电话，视频会议等。**
  
  2. ![1621578091016](assets/1621578091016.png)
  
* 再来看使用TCP协议的情况**，==尽管网际层中的IP协议==向上层==提供的是无连接不可靠的传输服务==**。也就是说，**IP数据报可能在传输过程中出现==丢失==或==误码==**。**==但只要运输层使用TCP协议==**，就可**==向其上层提供面向连接的可靠传输服务==**。我们可将其想象成，使用**==TCP协议的收发双方==**基于**==TCP连接的可靠信道==**进行数据传输。**不会出现误码、丢失、乱序、以及重复等传输差错**。TCP向上层提供**==面向连接==**的**==可靠传输==**服务(适用于**要求可靠传输**的应用，**例如文件传输**)。
  
  ### 首部对比
  
  * ![1621578308116](assets/1621578308116.png)
  * 一个TCP报文段由**首部**和**数据载荷**两部分构成。其首部格式如图所示，这比UDP用户数据报的首部复杂得多。**其最小长度为20字节，最大长度为60字**节。这是**因为TCP要实现==可靠传输==、==流量控制==、==拥塞控制==等服务**。**其首部自然会比较复杂，首部中的字段比较多，首部长度也比较长**。本节课到这里就结束了。
* 需要说明的是:TCP的流量控制和拥塞控制比较复杂，我们并未在本节课中介绍他们。有关它们的介绍，我们将在后续课程中进行。
  
  ### 小结
  
  * ![1621578472810](assets/1621578472810.png)

### 5.4 TCP的流量控制

* 1. ![1621756002917](assets/1621756002917.png)
  2. ![1621834748370](assets/1621834748370.png)
  
  * 假设主机A和B是因特网上的两台主机，**它们之间已经建立了TCP连接，==A给B发送数据，B对A进行流量控制==。**这是主机A中待发送的数据的字节序号。**假设主机A发送的每个TCP数据报文段可携带100字节数据，因此图中每个小格子表示100个字节数据的序号**。==在主机A和B建立TCP连接时==，B告诉A:"我的接受窗口为400"。因此，**主机A将自己的发送窗口也设置为400**。这意味着主机A**在未收到主机B发来的确认时**，可将**==序号落入发送窗口中的全部数据发送出去。==**
  
  3. ![1621835165614](assets/1621835165614.png)
  
  * 接下来，我们举例说明**主机B对A的流量控制**:**==主机A将发送窗口内序号1到100的数据封装成一个TCP报文段发送出去==**。**发送窗口内还有300字节可以发送**。这里的seq是TCP**报文段首部中的序号字段**，取值1表示**TCP报文段数据载荷**的**第一个字节的序号是1**。这里的**DATA表示这是TCP数据报文段**。主机A将发送窗口**内序号101到200的数据封装成一个TCP报文段发送出去。发送窗口内还有200字节可以发送**。主机A将发送窗口内序号201~300的数据封装成一个TCP报文段发送出去。**==但该报文段在传输过程中丢失了==**，主机A**==发送窗口内还有100字节可以发送==**。**主机B对主机A所发送的201号以前的数据进行累计确认。并在该累==计确认中将窗口字段的值调整为300，也就是对主机A进行流量控制。==**
  * 这里的**大写ACK是==TCP报文段首部中的标志位==，取值==1表示这是一个TCP确认报文段==**。**小写ack是TCP报文段首部中的==确认号字段==，取值201表示序号201之前的数据已全部正确接受**，**==现在希望收到序号201及其后续数据==**。**rwnd是TCP报文段首部中的==窗口字段，取值300表示自己的接收窗口大小为300==。**
  
  4. ![1621835723913](assets/1621835723913.png)
  
  * 主机A收到**该累计确认后，将发送窗口向前滑动，使已发送并收到确认的这些数据的序号移发送窗口。**
  
  5. ![1621835817918](assets/1621835817918.png)
  
  * 由于主机B在该累计确认中将自己的接收窗口调整为了300。**因此，主机A相应地将自己的发送窗口调整为300。**
  
  ****
  
  6. ![1621835958889](assets/1621835958889.png)
  
  * **目前，主机A发送窗口内的序号为201到500。也就是主机A还可以发送这300字节**。其中，**==201到300号字节是已发送的数据，若重传计时器超时，它们会被重传==。301到400号字节以及401~500号字节还未被发送。可被分别封装在一个TCP报文段中发送。**
  * 这里的大写ACK是TCP报文段首部中的标志位，取值1表示这是一个TCP确认报文段。小写ack是TCP报文段首部中的确认号字段，取值201表示序号201之前的数据已全部正确接受，现在希望收到序号201及其后续数据。rwnd是TCP报文段首部中的窗口字段，取值300表示自己的接收窗口大小为300。主机A收到该累计确认后，将发送窗口向前滑动，使已发送并收到确认的这些数据的序号移发送窗口。由于主机B在该累计确认中将自己的接收窗口调整为了300。因此，主机A相应地将自己的发送窗口调整为300。目前，主机A发送窗口内的序号为201~500。也就是主机A还可以发送这300字节。其中，201~300号字节是已发送的数据，若重传计时器超时，它们会被重传。301~400号字节以及401~500号字节还未被发送。可被分别封装在一个TCP报文段中发送。
  
  *****
  
  7. ![1621836266817](assets/1621836266817.png)
  
  * **==主机A现在可将发送缓存中序号1到200的字节数据全部删除了==，因为已经收到了主机B对他们的累计确认**。主机A将发送窗口内序号**301到400的数据封装成一个TCP报文段发送出去。发送窗口内还有100个字节可以发送**。**主机A将发送窗口内序号401到500的数据封装成一个TCP报文段发送出去。至此，序号落在发送窗口内的数据==已经全部发送出去了，不能再发送新数据了==**。现在，**发送窗口内序号201~300这100个字节数据的==重传计时器超时==了。==主机A将它们重新封装成一个TCP报文段发送出去，暂时不能发送其他数据==，主机B收到该重传的TCP报文段后，对主机A所发送的501号以前的数据进行累计确认，==并在该累计确认中将窗口字段的值调整为100，这是主机B对主机A进行的第二次流量控制。==**
  
  8. ![1621836481424](assets/1621836481424.png)
  
  * 主机A收到该累计确认后，将发送窗口向前滑动，**使已发送并收到确认的这些数据的序号移出发送窗口。**
  
  9. ![1621836600688](assets/1621836600688.png)
  
  * **由于主机B在该累计确认中将自己的接收窗口调整为了100。因此，主机A相应地将自己的发送窗口调整为100。**
  
  10. ![1621836695900](assets/1621836695900.png)
  
  * 目前，主机A发送窗口内的序号为501到600。也就是主机A还可以发送这100字节，**==主机A现在可将发送缓存中序号201~500的字节数据全部删除了==，因为已经收到了主机B对它们的累计确认**。**主机A将发送窗口内序号501到600的数据封装成一个TCP报文段发送出去。==至此，序号落在发送窗口内的数据已经全部发送出去了，不能再发送新数据了。==**
  * 主机A现在可将发送缓存中序号1到200的字节数据全部删除了，因为已经收到了主机B对他们的累计确认。主机A将发送窗口内序号301到400的数据封装成一个TCP报文段发送出去。发送窗口内还有100个字节可以发送。主机A将发送窗口内序号401到500的数据封装成一个TCP报文段发送出去。至此，序号落在发送窗口内的数据已经全部发送出去了，不能再发送新数据了。现在，发送窗口内序号201到300这100个字节数据的重传计时器超时了。主机A将它们重新封装成一个TCP报文段发送出去，暂时不能发送其他数据，主机B收到该重传的TCP报文段后，对主机A所发送的501号以前的数据进行累计确认，并在该累计确认中将窗口字段的值调整为100，这是主机B对主机A进行的第二次流量控制。主机A收到该累计确认后，将发送窗口向前滑动，使已发送并收到确认的这些数据的序号移出发送窗口。由于主机B在该累计确认中将自己的接收窗口调整为了100。因此，主机A相应地将自己的发送窗口调整为100。目前，主机A发送窗口内的序号为501到600。也就是主机A还可以发送这100字节，主机A现在可将发送缓存中序号201到500的字节数据全部删除了，因为已经收到了主机B对它们的累计确认。主机A将发送窗口内序号501~600的数据封装成一个TCP报文段发送出去。至此，序号落在发送窗口内的数据已经全部发送出去了，不能再发送新数据了。
  
  *****
  
  11. ![1621837025603](assets/1621837025603.png)
  
  * 主机B对主机A所发送的601号以前的数据进行累计确认，并在该累计确认中将窗口字段的值调整为0，这是主机B对主机A进行的第三次流量控制。主机A收到该累计确认后，将发送窗口向前滑动，使已发送并收到确认的这些数据的序号移出发送窗口。
  
  12. ![1621837140920](assets/1621837140920.png)
  
  * 由于主机B在该累计确认中将自己的接收窗口调整为了0，因此，主机A也相应地将自己的发送窗口调整为0。**==目前，主机A不能再发送一般的TCP报文段了。==**
  
  13. ![1621837217418](assets/1621837217418.png)
  
  * 主机A现在可将发送缓存中序号501~600的字节数据全部删除了，**因为已经收到了主机B对它们的累计确认。**
  * 主机B对主机A所发送的601号以前的数据进行累计确认，并在该累计确认中将窗口字段的值调整为0，这是主机B对主机A进行的第三次流量控制。主机A收到该累计确认后，将发送窗口向前滑动，使已发送并收到确认的这些数据的序号移出发送窗口。由于主机B在该累计确认中将自己的接收窗口调整为了0，因此，主机A也相应地将自己的发送窗口调整为0。目前，主机A不能再发送一般的TCP报文段了。主机A现在可将发送缓存中序号501~600的字节数据全部删除了，因为已经收到了主机B对它们的累计确认。
  
  *****
  
  14. ![1621837393173](assets/1621837393173.png)
  
  * 假设**主机B向主机A发送了零窗口的报文段后不久，==主机B的接收缓存又有了一些存储空间==**。**于是，==主机B向主机A发送了接收窗口等于300的报文段==。然而，==这个报文段在传输过程中丢失了==。主机A一直等待主机B发送的非零窗口的通知，而主机B也一直在等待主机A发送的数据。如果不采取措施，这种==互相等待而形成的死锁局面==将一直持续下去。**
  
  15. ![1621837706617](assets/1621837706617.png)
  
  * **==为了解决这个问题，TCP为每一个连接设有一个持续计时器==**。**只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器超时，就发送一个零窗口探测报文，仅携带一字节的数据**。而对方在确认这个探测报文段时，给出自己现在的接受窗口值，如果接收窗口仍然是0，那么收到这个报文段的一方就重新启动持续计时器。如果接收窗口不是0，那么死锁的局面就可以被打破了。
  * 在本例中，主机A收到零窗口通知时，就启动一个持续计时器。当持续计时器超时，主机A立刻发送一个仅携带一字节数据的零窗口探测报文段。假设主机B此时的接收窗口又为0了，主机B就在确认这个零窗口探测报文时，给出自己现在的接收窗口值为0。主机A再次收到零窗口通知，就再次启动一个持续计时器。当持续计时器超时，主机A立刻发送一个零窗口探测报文段。假设主机B此时的接收缓存又有了一些存储空间，于是将自己的接收窗口调整为了300，主机B就在确认这个零窗口探测报文段时，给出自己现在的接收窗口值为300。这样就打破了死锁的局面。
  * 同学们可能会有这样的疑问:主机A所发送的零窗口探测报文段到达主机B时，如果主机B此时的接收窗口仍然为0，那么主机B根本就无法接受该报文段，又怎么会针对该报文段给主机A发回确认呢？实际上TCP规定，即使接收窗口为0，也必须接受零窗口探测报文段、确认报文段、以及携带有紧急数据的报文段。
  
  16. ![1621837963074](assets/1621837963074.png)
  
  * 请大家再来思考一下这个问题:如果零窗口探测报文段丢失了，会出现怎样的问题呢？还能否打破死锁的局面呢？回答是肯定的。因为零窗口探测报文段也有重传计时器。当重传计时器超时后，零窗口探测报文段会被重传。接下来，我们来做一个相关的练习题。
  
  ### 习题
  
  * ![1621838250066](assets/1621838250066.png)
  * 而在我们本节课的举例中，为了简单起见，我们忽略了拥塞控制，也就是认为TCP发送方的发送窗口等于接收方的接收窗口。
  * ![1621838286076](assets/1621838286076.png)
  
  ### 小结
  
  * ![1621838351374](assets/1621838351374.png)

### 5.5 TCP的拥塞控制

* 1. ![1621838740874](assets/1621838740874.png)

  * 代表单位时间内输入给网络的分组数量。
  * 代表单位内从网络输出的分组数量。
  * 具有理想拥塞控制的网络，在吞吐量达到饱和之前，网络吞吐量应等于所输入的负载，故吞吐量曲线是45度的斜线。但当输入负载超过某一限度时，由于网络资源受限，吞吐量就不再增长而保持水平线。也就是吞吐量达到饱和。这就表明输入的负载中有一部分损失掉了。例如，输入到网络中的某些分组被某个结点丢弃了。虽然如此，在这种理想的拥塞控制作用下，网络的吞吐量仍然维持在其所能达到的最大值。然而，实际的网络情况就很不同了。

  2. ![1621838890126](assets/1621838890126.png)

  * 我们再来看这条吞吐量曲线，随着输入负载的增大，网络吞吐量的增长率逐渐减小。也就是在网络吞吐量还未达到饱和时，就已经有一部分的输入分组被丢弃了，当网络的吞吐量明显地小于理想的吞吐量时，网络就进去了轻度拥塞的状态。更值得注意的是，当输入负载达到某一数值时，网络的吞吐量反而随输入负载的增大而减小，这是网络就进去了拥塞状态。当输入负载继续增大到某一数值时，网络的吞吐量就减小为0，此时网络就无法工作了，这就是所谓的死锁。因此，进行拥塞控制是非常有必要的。
  * 实际的拥塞控制曲线应该尽量接近理想的拥塞控制曲线。
  * 接下来，我们介绍TCP的四种拥塞控制算法。

  *****

  3. ![1621839066488](assets/1621839066488.png)
  4. ![1621839211841](assets/1621839211841.png)

  * 假设这是TCP的发送方和接收方，发送方给接收方发送TCP数据报文段。接收方收到后，给发送方发送TCP确认报文段，发送方要维护一个叫做拥塞窗口的状态变量，其值取决于网络的拥塞程度，并且动态变化。

  *****

  5. ![1622128485401](assets/1622128485401.png)
  
  * 为了更清楚地显示出拥塞控制过程，我们还可以绘制这样一幅拥塞窗口随传输轮次变化的图。横坐标为传输轮次。传输轮次是指发送方给接收方发送数据报文段后，接收方给发送方发回相应的确认报文段。一个传输轮次所经历的时间，其实就是往返时间。请注意:往返时间并非是恒定的数值。使用传输轮次是为了强调把拥塞窗口所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个报文段的确认。
  * 纵坐标是拥塞窗口，它会随网络拥塞程度以及所使用的拥塞控制算法动态变化。在TCP双方建立逻辑连接关系时，拥塞窗口的值被设置为1。我们在图上标出传输轮次0时的拥塞窗口值为1。另外，还需要设置慢开始门限的初始值，本例采用16，我们也将它在图中标出。在执行慢开始算法时，发送方每收到一个对新报文段的确认时，就把拥塞窗口值加1，然后开始下一轮的传输。当拥塞窗口值增长到慢开始门限值时，就改为执行拥塞避免算法。由于发送方当前的拥塞窗口值是1，而发送窗口值等于拥塞窗口值。因此，发送方当前只能发送一个TCP数据报文段。换句话说，拥塞窗口的值是几，就能发送几个数据报文段。如图所示，发送方发送0号数据报文段。接收方收到后，给发送方发回对0号报文段的确认报文段。
  
  6. ![1622128679553](assets/1622128679553.png)
  
  * 发送方收到该确认报文段后，将拥塞窗口值加1增加到2，我们在图中标出该值。
  * 这意味着发送方，现在可以发送1~2号共两个数据报文段。接收方收到后，给发送方发回对1到2号报文段的确认报文段。
  
  7. ![1622128818919](assets/1622128818919.png)
  
  * 发送方收到后，将拥塞窗口值加2增大到4，我们仍在图中标出该值。
  
  8. ![1622128984921](assets/1622128984921.png)
  
  * 发送方现在可以发送36号共四个数据报文段。接收方收到后，给发送方发回对3~6号报文段的确认报文段。发送方收到后，将拥塞窗口值加4增加到8。
  
  9. ![1622129073756](assets/1622129073756.png)
  
  * 发送方收到后，将拥塞窗口值加4增加到8，我们在图中标出该值。
  
  10. ![1622129144964](assets/1622129144964.png)
  
  * 发送方现在可以发送7到14号共8个数据报文段。接收方收到后，给发送方发回7到14号报文段的确认报文段。发送方收到后，将拥塞窗口值加8增大到16。
  
  11. ![1622129291877](assets/1622129291877.png)
  
  * 发送方收到后，将拥塞窗口值加8增大到16，我们在图中标出该值，发送方当前的拥塞窗口值，已经增大到了慢开始门限值。之后，我们要改用拥塞避免算法。
  
  ****
  
  12. ![1622170141852](assets/1622170141852.png)
  
  * 之后，我们要改用拥塞避免算法，也就是每个传输轮次结束后，拥塞窗口值只能线性加1。而不像慢开始算法那样，每个传输轮次结束后，拥塞窗口值按指数规律增大。发送方现在可以发送15到30号共16个数据报文段。接收方收到后，给发送方发回对15到30号报文段的确认报文段。发送方收到后，将拥塞窗口值加1增大到17。
  
  13. ![1622170253541](assets/1622170253541.png)
  
  * 发送方收到后，将拥塞窗口值加1增大到17，我们在图中标出该值。
  
  14. ![1622170371791](assets/1622170371791.png)
  
  * 发送方现在可以发送31到47号共17个数据报文段。接收方收到后，给发送方发回对31到47号报文段的确认报文段。发送方收到后，将拥塞窗口值加1增大到18。
  
  15. ![1622170485255](assets/1622170485255.png)
  
  * 送方收到后，将拥塞窗口值加1增大到18，我们在图中标出该值。
  
  16. ![1622199009532](assets/1622199009532.png)
  
  * 随着传输轮次的增加，拥塞窗口值每轮次都线性加1。例如，当前拥塞窗口值增加到了24。发送方现在可以发送171到194号共24个数据报文段。假设这24个数据报文段在传输过程中丢失了几个。
  
  17. ![1622199157618](assets/1622199157618.png)
  
  * 这必然会造成发送方对这些丢失报文段的**==超时(这意味着会重新执行慢开始算法。)==**重传。发送方以此判断网络很可能出现了拥塞，需要进行以下工作：
  
    * 将慢开始门限值更新为发生拥塞时拥塞窗口值的一半，网络发生拥塞时的拥塞窗口值是24，因此更新慢开始门限值为该值的一半，即12，如图所示。
  
    * 将拥塞窗口值减小为1，并重新开始执行慢开始算法。
  
      ![1622199389818](assets/1622199389818.png)
  
    
  
  18. ![1622199512399](assets/1622199512399.png)
  
  * 如图所示。**当慢开始执行到==拥塞窗口值增大到新的慢开始门限值==时**，**就停止使用慢开始算法**。**转而执行拥塞避免算法**。如图所示。
  * 通过本例可以看出，**TCP发送方一开始使用慢开始算法，让拥塞窗口值==从1开始按指数规律增大==，当==拥塞窗口值增大到慢开始门限值==时，==停止使用慢开始算法。转而执行拥塞避免算法==。让拥塞窗口值==按线性加1==的规律增大。当==发生超时重传==时，就==判断网络很可能出现了拥塞==。采取相应的措施，一方面==将慢开始门限值更新为发生拥塞时拥塞窗口值的一半==，另一方面将==拥塞窗口值减小为1，并重新开始执行慢开始算法==。**
  
  19. ![1622199876030](assets/1622199876030.png)
  
  * **拥塞窗口值==又从1开始按指数规律==增大，当==增大到了新的慢开始门限值==时，停止使用慢开始算法，==转而执行拥塞避免算法==。让拥塞窗口值==按线性加1的规律==增大。**
  * **需要注意的是:**
    * "慢开始"**是指一开始向网络注入的报文段少**，==而并不是指拥塞窗口值增长速度慢==。
    * "拥塞避免"也**并非指完全能够避免拥塞**，而是指在拥塞避免阶段将**拥塞窗口控制为按线性规律增长**，**==使网络比较不容易出现拥塞。==**
  
  ******
  
  20. ![1622200291911](assets/1622200291911.png)
  
  * 例如，在之前的例子中，当拥塞窗口值增大到24时，发生了超时重传，而网络此时并没有发生拥塞，但是发送方却误认为网络发生了拥塞。于是，发送方把拥塞窗口的值减小为1，并错误地启动慢开始算法，因而降低了传输效率。
  
  21. ![1622200590897](assets/1622200590897.png)
  22. ![1622200948573](assets/1622200948573.png)
  
  * 我们来**举例说明快重传算法**，发送方发送1号数据报文段，接收方收到后给发送方发回对1号报文段的确认。在该确认报文段到达发送方之前，发送方还可以将发送窗口内的2号数据报文段发送出去，接收方收到后给发送方发回对2号报文段的确认。**在该确认报文段到达发送方之前,发送方还可以将发送窗口内的3号数据报文段发送出去，==但该报文段丢失了==，接收方自然不会给发送方发回针对该报文段的确认**。**发送方还可以将发送窗口内的==4号数据报文段发送出去==，接收方收到后==发现这不是按序到达的报文段==，因此给发送方==发回针对2号报文段的重复确认==。表明:"我现在希望收到的是3号报文段，但是，我没有收到3号报文段，而是收到了未按序到达的报文段"。**
    发送方还可以将发送窗口内的5号数据报文段发送出去，接收方收到后发现这不是按序到达的报文段，因此给发送方**==发回针对2号报文段的重复确认==**。发送方还可以将发送窗口内的6号数据报文段发送出去，接收方收到后发现这不是按序到达的报文段，因此给发送方发回**==针对2号报文段的重复确认==**。**至此，发送方会==收到3个连续的、对2号报文段的重复确认。就立即重传3号报文段==**。接收方收到后，**给发送方发回针对6号报文段的确认，==表明序号到6为止的报文段都正确接收了==。这样就不会要造成对3号报文段的超时重传，而是==提早进行了重传==**。对于个别丢失的报文段（就是此例），发送方**不会出现超时重传，==也就不会误认为出现了拥塞而错误地降低拥塞窗口的值为最小值1==**，使用快重传可以使整个网络的吞吐量提高约20%。
  
  23. ![1622201476031](assets/1622201476031.png)
  24. ![1622201654773](assets/1622201654773.png)
  
  ******
  
  25. ![1622201808068](assets/1622201808068.png)
  26. ![1622201985678](assets/1622201985678.png)
  
  ****
  
  27. ![1622202020966](assets/1622202020966.png)
  
  

### 5.6 TCP超时重传时间的选择

  * 1. ![1622202627867](assets/1622202627867.png)

    * 假设A和B是因特网上的两台主机，它们之间已经建立了TCP连接。纵坐标为时间，现在，主机A给主机B发送TCP数据报文段0，并记录下当前的时间。主机B收到后，给主机A发送相应的确认报文段。主机A收到确认报文段后，记录下当前的时间，那么主机A记录下的这两个时间，它们的差值就是报文段的往返时间RTT。由于这是第0个报文段的RTT，我们就用RTT0来表示。试想一下，如果我们将超时重传时间RTO的值，设置得比RTT0的值小，会出现怎样的情况呢？
    * 很显然，这会引起报文段不必要的重传，使网络负荷增大!

    2. ![1622202740399](assets/1622202740399.png)

    * 那么，如果将超时重传时间RTO的值设置得远大于RTT0的值呢？又会出现怎样的情况呢？很显然，这会使重传推迟的时间太长，使网络的空闲时间增大，降低了传输效率。

    3. ![1622202891422](assets/1622202891422.png)

    * 综合上述两种情况，我们可以得出这样的结论:超时重传时间RTO的值，应该设置为略大于报文段往返时间RTT的值。至此，同学们可能会觉得，超时重传时间的选择也并不是很复杂嘛。然而，TCP下层是复杂的互联网环境，主机A所发送的报文段可能只经过一个高速率的局域网，也有可能经过多个低速率的网络。并且，每个IP数据报的转发路由还可能不同。例如，现在主机A给主机B发送TCP数据报文段1，主机B收到后，给主机A发送相应的确认报文段。主机A这次测得的报文段往返时间RTT1如图所示。显然，RTT1远大于RTT0。如果超时重传时间RTO还是我们之前所确定的略大于RTT0的话，这对于数据报文段1是不合适的，会造成该报文段不必要的重传。

    4. ![1622203144548](assets/1622203144548.png)

    * 这样看来，超时重传时间的选择确实不那么简单了。我们不能直接使用某次测量得到的RTT样本来计算超时重传时间RTO。但是，利用每次测得的RTT样本计算加权平均往返时间RTTs，这样可以得到比较平滑的往返时间。当测量到第一个RTT样本时，RTTs的值直接取为第一个RTT样本的值。以后每测量到一个RTT样本时，都按该公式来计算新的RTTs的值。

    5. ![1622203761785](assets/1622203761785.png)

    * 我们可以发现，不管是RTTs还是RTTD，都是基于所测量到的RTT样本进行计算的。如果所测量到的RTT样本不正确，那么所计算出的RTTs和RTTD自然就不正确。进而所计算出的超时重传时间RTO也就不正确。

    ****

    6. ![1622204118576](assets/1622204118576.png)

    * 然而，往返时间RTT的测量确实比较复杂。我们来举例说明，主机A给主机B发送TCP数据报文段，但该报文段在传输过程中丢失了。当超时重传计时器超时后，主机A就重传该报文段。主机B收到后，给主机A发送确认报文段。现在问题来了:主机A收到该确认报文段后，无法判断该报文段是对原报文段的确认，还是对重传报文段的确认。该报文段实际上是对重传报文段的确认。也就是说，正确的RTT应该是这一段时间。但是，如果主机A误将该确认当作是对原报文段的确认，也就是误认为这段时间是RTT。则所计算出的RTTs和RTO就会偏大，降低了传输效率。

    7. ![1622204483517](assets/1622204483517.png)

    * 主机A给主机B发送TCP数据报文段，主机B收到后，给主机A发送确认报文段。由于某种原因，该确认报文段没有在正常时间内到达主机A。这必然会导致主机A对之前所发送的数据报文段的超时重传。现在问题又来了:主机A收到迟到的确认报文段后，无法判断该报文段是对原报文段的确认，还是对重传报文段的确认。该报文段实际上是对原报文段的确认。也就是说，正确的RTT应该是这一段时间。但是，如果主机误将该确认当作是对重传报文段的确认，也就是误认为这段时间是RTT。则所计算出的RTTs和RTO就会偏小，这会导致报文段没必要的重传，增大网络负荷;
    * 通过这两个例子可以看出，当发送方出现超时重传后，收到确认报文段时，是无法判断出该确认到底是对原报文段的确认，还是对重传报文段的确认。也就是无法准确测量出RTT，进而无法正确计算超时重传时间RTO。

    ****

    8. ![1622205308728](assets/1622205308728.png)

    ****

    9. ![1622205417739](assets/1622205417739.png)
    *****
    10. ![1622205509436](assets/1622205509436.png)
    11. ![1622205600179](assets/1622205600179.png)
    12. ![1622205650691](assets/1622205650691.png)
    
    ****
    
    ***
    
    13. ![1622205737728](assets/1622205737728.png)
    
    *****
    
    14. ![1622205981334](assets/1622205981334.png)
    
    * 假设这是测量到的第五个RTT样本，但是根据RTO的值可知，在收到确认之前就会发生超时重传。我们之前介绍过，若出现超时重传，新RTO=2倍的旧RTO。则不采用上述公式计算RTO，而是将新RTO的值取为旧RTO值的2倍。因此，RTO5的值取为两倍的RTO4的值。
    
    ***
    
    ***
    
    15. ![1622206028695](assets/1622206028695.png)

### 5.7 TCP可靠传输的实现

* 1. ![1622206475851](assets/1622206475851.png)

  * TCP基于**==以字节为单位的滑动窗口==**来实现可靠传输。
  * 这是因特网上的两台主机，它们之间已经建立了一个TCP连接。

  2. ![1622206677889](assets/1622206677889.png)

  * **为了简单起见，我们假定数据传输只在一个方向进行。换句话说，发送方给接收方发送TCP数据报文段，接收方给发送方发送相应的TCP确认报文段。这样的好处是使讨论仅限于两个窗口，也就是发送方的发送窗口和接收方的接收窗口。==TCP的滑动窗口是以字节为单位的==。如图所示，这是发送方待发送数据字节的序号。为了方便讲解和在有限的屏幕上显示更多的字节序号，字节序号的值都取得很小。**

  3. ![1622206800851](assets/1622206800851.png)

  * 现在，假设发送方收到了一个来自接收方的确认报文段。**在报文段首部中的窗口字段的值为20，也就是接收方表明自己的接收窗口的尺寸为20字节。==确认号字段的值为31，这表明接收方希望收到下一个数据的序号是31，而序号30为止的数据已经全部正确接收了==**。

  4. ![1622208087367](assets/1622208087367.png)

  * **==因此，发送方根据这两个字段的值构造出自己的发送窗口==**，如图所示。
  * **为了简单起见，我们假定网络不存在拥塞问题，也就是发送方在构造自己的发送窗口时，仅考虑接收方的接收窗口，而不考虑拥塞窗口**。
  * 由于本例中接收方告诉发送方自己的接收窗口尺寸为20，因此发送方将自己的发送窗口尺寸也设置为20。发送方在没有收到接收方确认的情况下，可以把发送窗口内的数据一次全部发送出去。**==凡是已经发送过的数据，在未收到确认之前，都必须暂时保留，以便在超时重传时使用==**。这是发送窗口的后沿，这是发送窗口的前沿。发送窗口后沿的后面部分，是已发送并已收到确认的数据字节的序号。这些数据字节显然不需要再保存在发送缓存中了，可以将它们删除。发送窗口前沿的前面部分，是当前不允许发送的数据字节的序号。
  * 我们来看看发送窗口后沿的移动情况，有以下两种可能：
    * 一种是不动，也就是没有收到新的确认，发送窗口的后沿不会移动。
    * 另一种是向前移动，也就是收到了新的确认，发送窗口的后沿向前移动。
    * **发送窗口的后(左边是后，右边是前)沿不可能向后移动，因为不能撤销掉已收到的确认**。
  * 再来看发送窗口前沿的移动情况，有以下三种可能：
    * 通常情况下，发送窗口的前沿是不断向前移动的。
    * 但也有可能不动，一种是由于没有收到新的确认，接收方通知的窗口大小也没有改变。另一种是收到了新的确认，可向前移动相应位置，但接收方通知的窗口缩小了，前沿应该向后回缩，如果向前移动和向后回缩的尺寸恰好相等，就会使得发送窗口的前沿不动。
    * **发送窗口的前沿还可能向后收缩，这发生在接收方通知的窗口变小了，但TCP标准强烈不赞成这样做，因为很可能发送方在收到这个通知之前，就已经发送了窗口中的许多数据，现在又要收缩窗口，不让发送这些数据，显然就会产生错误**。

  *****

  5. ![1622464890509](assets/1622464890509.png)

  * 现在假定发送方将发送窗口内序号31到41的数据封装在几个不同的报文段中发送出去。此时发送窗口的位置并没有改变。发送窗口内序号31到41的数据已经发送但未收到确认，而序号42到50的数据是允许发送但还未发送的。
  
  6. ![1622465045540](assets/1622465045540.png)
  
  * 请同学们思考一下，我们如何描述发送窗口的状态呢？换句话说，如果我们要编程实现滑动窗口机制，那么对于发送窗口的状态应该如何标记和维护呢?如图所示，可以使用三个指针P1，P2，P3分别指向相应的字节序号。这样，小于P1的就是已发送并已收到确认的部分，大于等于P3的是不允许发送的部分，P3减P1可以得出当前发送窗口的尺寸，P2减P1可以得出已发送但尚未收到确认的字节数量，P3减P2可以得出允许发送但当前尚未发送的字节数量。
  
  ****
  
  7. ![1622465196465](assets/1622465196465.png)
  
  * 我们再来看看接收方的接收窗口，它的尺寸为20。在接收窗口外面到30号为止的数据，是已经发送过相应确认并已交付给应用进程的数据。因此无需再保留这些数据，可将它们从接受缓存中删除了。接收窗口内31到50号数据是允许接收的数据，接收窗口外51号及其后续数据，目前不允许接收。假设发送方之前发送的封装有32和33号数据的报文段到达了接收方。
  
  8. ![1622465342694](assets/1622465342694.png)
  
  * 由于数据序号落在接收窗口内，所以接收方接受它们，并将它们存入接收缓存(图中红色部分，忘记标注了)。但是，它们是未按序到达的数据，因为31号数据还没有到达，这有可能是丢了，也有可能是滞留在网络中的某处。请注意:接收方只能对按序收到的数据中的最高序号给出确认。因此，接收方发出的确认报文段中的确认序号仍然是31。也就是希望收到31号数据。窗口字段的值仍是20，表明接收方没有改变自己的接收窗口的大小。
  
  9. ![1622465579438](assets/1622465579438.png)
  
  * 发送方收到该确认报文段后，发现这是一个针对31号数据的重复确认，就知道接收方收到了未按序到达的数据。由于这是针对31号数据的第一个重复确认(为什么是重复确认，而不是确认？)，因此这并不会引起发送方针对该数据的快重传。另外，接收方通知的窗口尺寸仍是20，因此发送方仍保持自己的发送窗口尺寸为20。现在假设封装有31号数据的报文段到达了接收方。
  
  10. ![1622465683821](assets/1622465683821.png)
  
  * 接收方接受该报文段，将其封装的31号数据存入接收缓存。接收方现在可将接收到的31到33号数据交付给应用进程。
  
  11. ![1622465801605](assets/1622465801605.png)
  
  * 然后将接收窗口向前移动3个序号，并给发送方发送确认报文段。该确认报文段中的窗口字段的值仍为20，表明接收方没有改变自己接收窗口的大小，确认号字段的值为34，这表面接收方已经收到了序号33为止的全部数据。
  
  ****
  
  12. ![1622465871689](assets/1622465871689.png)
  
  * 现在。假设又有几个数据报文段到达了接收方，它们封装有37，38以及40号数据。这些数据的序号虽然落在接收窗口内，但它们都是未按序到达的数据，
  
  13. ![1622466026499](assets/1622466026499.png)
  
  * 只能先暂存在接收缓存中。
  
  14. ![1622466106128](assets/1622466106128.png)
  
  * 假设接收方先前发送的确认报文段到达了发送方，
  
  15. ![1622466197092](assets/1622466197092.png)
  
  * 发送方接收后，将发送窗口向前滑动3个序号，发送窗口的尺寸保持不变。这样就有新序号51到53落入发送窗口内，而序号31到33移出了发送窗口，
  
  16. ![1622466373600](assets/1622466373600.png)
  
  * 现在可将31到33号数据从发送缓存中删除了，因为已经收到了接收方针对它们的确认。发送方继续将发送窗口内序号42到53的数据，封装在几个不同的报文段中发送出去。现在，发送窗口内的序号已经用完了。
  * 发送方在未收到接收方发来确认的情况下，不能再发送新的数据。序号落在发送窗口内的已发送数据，如果迟迟收不到接收方的确认，则会产生超时重传。
  
  ***
  
  17. ![1622466967696](assets/1622466967696.png)
  
  * 接下来，我们还要对TCP可靠传输的实现做几点补充说明。
  
  ******
  
  18. ![1622467215109](assets/1622467215109.png)
  
  * 一些细节有时间再说，也不太重要。
  
  ****
  
  19. ![1622467465792](assets/1622467465792.png)
  
  * 一些细节有时间再说，
  
  ****
  
  20. ![1622467567145](assets/1622467567145.png)
  
  ​     

### 5.8.1 TCP的运输连接管理——TCP的连接建立

* **==注意确认标识位(ACK)和确认号(ack)是完全不同的，确认标识位是对确认号的值是否有效的确认。==**

* 1. ![1622391470371](assets/1622391470371.png)
  2. ![1622391576566](assets/1622391576566.png)
  3. ![1622391990988](assets/1622391990988.png)

  * **这是两台要基于TCP进行通信的主机**，**其中一台主机中的某个应用进程==主动发起TCP连接建立，称为TCP客户==**。**另一台主机中==被动等待TCP连接建立的应用进程，称为TCP服务器==。我们可以==将TCP建立连接的过程比喻为"握手"==**。**"握手"需要在==TCP客户和服务器之间交换三个TCP报文段==。最初，==两端的TCP进程都处于关闭状态==**。**一开始，==`TCP服务器进程首先创建传输控制块(socket函数)`==。用来==存储TCP连接中的一些重要信息==。例如。`TCP连接表。指向发送和接收缓存的指针、指向重传队列的指针、当前发送和接收序号等`。==之后，就准备接受TCP客户进程的连接请求==**。**此时，==TCP服务器进程就进入监听状态==，==等待==TCP客户进程的连接请求。==TCP服务器进程是被动等待==自己来自TCP客户进程的连接请求，而不是主动发起，==因此称为被动打开连接==**。TCP客户进程**==也是首先创建传输控制块==**。然后，**在打算建立TCP连接时，==向TCP服务器进程发送TCP连接请求报文段，并进入`同步已发送状态`==**。**TCP连接请求报文段首部中的`同步位SYN被设置为1，表明这是一个TCP连接请求报文段`。序号字段seq被设置了一个初始值x(可任意指定，不要太离谱)，作为TCP客户进程所选择的初始序号。请注意:==`TCP规定SYN被设置为1的报文段不能携带数据，但要消耗掉一个序号`==。由于TCP连接建立是由==TCP客户主动发起的，因此称为主动打开连接==。TCP服务器进程收到TCP连接请求报文段后，==如果同意建立连接==，==则向TCP客户进程发送TCP连接请求确认报文段，并进入`同步已接收状态`==。该报文段首部中的==`同步位SYN和确认位ACK都设置为1`，表明这是一个TCP连接请求确认报文段==。序号字段==seq被设置了一个初始值y(可随意设定)作为TCP服务器进程所选择的初始序号==。==`确认号字段ack`的值被设置成了x+1(注意x是TCP客户进程所选择的初始序号)，这是对TCP客户进程所选择的初始序号的确认==。**
  * **==请注意:这个报文段(TCP连接请求确认报文段)也不能携带数据，因为它是SYN被设置为1的报文段，但同样要消耗掉一个序号。==**
  
  4. ![1622392734870](assets/1622392734870.png)
  
  * **TCP客户进程收到TCP连接请求确认报文段后，==还要向TCP服务器进程发送`一个普通的TCP确认报文段`(注意没有SYN了)==，并进入`连接已建立`状态**。**该报文段首部中的==确认位ACK被设置为1，表明这是一个`普通的(没有SYN了)`TCP确认报文段==。序号字段==seq被设置为x+1，这是因为TCP客户进程发送的第一个TCP报文段的序号为x，并且不携带数据，因此第二个报文段的序号为x+1(因为第一次发送TCP连接请求报文段消耗掉了一个序号)==。请注意:==TCP规定`普通的`TCP确认报文段可以携带数据，`但如果不携带数据，则不消耗序号`(不消耗不是不使用，序号都是要使用的。相当于我使用了又还回来，那么下一次我仍可以使用x+1这个序号)。在这种情况下，所发送的下一个数据报文段的序号仍是x+1(很重要我觉得)==。==确认号字段ack被设置为y+1，这是对TCP服务器进程所选择的初始序号(TCP连接请求确认报文段中seq=y)的确认==。**
  
  5. ![1622427652411](assets/1622427652411.png)
  
  * **TCP服务器进程==收到该确认报文段后也进入连接已建立状态==。现在，==TCP双方都进入了连接已建立状态==。它们可以基于已建立好的TCP连接，进行==可靠的数据传输==了。**
  
  6. ![1622427860968](assets/1622427860968.png)
  
  ****
  
  7. ![1622427941971](assets/1622427941971.png)
  
  * **请同学们思考这样一个问题:为什么TCP客户进程最后还要发送一个普通的TCP确认报文段呢？这是否多余？换句话说，能否使用"两报文"握手建立连接呢？答案是"并不多余"，不能简化为"两报文握手"。**
  
  8. ![1622428434848](assets/1622428434848.png)
  
  * **==我们来举例说明，考虑这样一种情况==:TCP客户进程发出一个TCP连接请求报文段。但该报文段在某些网络结点==长时间`滞留`(并不是消失了，如果消失了还不是那么棘手)==了。这必然会造成该报文段的==超时重传==，假设==重传的报文段被TCP服务器进程正常接收==。TCP服务器进程==给TCP客户进程发送一个TCP连接请求确认报文段，并进入连接已建立状态==。请注意:==由于我们改为"两报文握手"==，因此TCP服务器进程发送完TCP连接请求确认报文段后，==进入的是连接已建立状态==，而==不像"三报文握手"那样进入同步已接收状态==，并等待TCP客户进程发来==针对TCP连接请求确认报文段==的==普通确认报文段==。**
  * **TCP客户进程收到TCP连接请求确认报文段后，==进入TCP连接已建立状态==。但==不会给TCP服务器进程发送针对该报文段的普通确认报文段==。**现在，**TCP双方==都处于连接已建立状态==。它们==可以相互传输数据==。之后，可以通过=="四报文挥手"来释放连接==。然后TCP双方都进入了==关闭==状态**。**==一段时间后==，之前==滞留==在网络中的那个==失效的TCP连接请求报文段到达了TCP服务器进程==。TCP服务器进程会==误认为==这是TCP客户进程==又发起了一个新的TCP连接请求==**。**于是给TCP客户进程==发送TCP连接请求确认报文段==，==并进入连接已建立状态==。该报文段到达TCP客户进程，==由于TCP客户进程并没有发起新的TCP连接请求==，并==且处于关闭状态==，==因此不会理会该报文段==**。**但==TCP服务器进程==已进入连接已建立状态，它==`认为新的TCP连接已经建立好了`==，==`并一直等待TCP客户进程发来数据`==，这将==`白白浪费TCP服务器进程所在主机`==的很多资源。**
  
  9. ![1622428971017](assets/1622428971017.png)
  
  * 综上所述，**采用"三报文握手"而不是"两报文握手"来建立TCP连接，==是为了防止已失效的连接请求报文段突然又传送到了TCP服务器(进程)==，因而导致错误。**
  
  *****
  
  10. ![1622429430072](assets/1622429430072.png)
  
  * **这是主机乙中TCP服务器进程给主机甲中TCP客户进程发送的TCP连接请求确认报文段。==其首部中的同步位SYN和确认位ACK的值都被设置为1，表面这是一个TCP连接请求确认报文段。==**
  
  * **==`确认号字段ack`(小写的)的值是对主机甲中TCP客户进程所选择初始序号11220的确认，因此为11221(11220已正确接收，期待收到11221)==。至此，我们就已经可以选出正确答案为选项C了。==序号字段seq的值，是主机乙中TCP服务器进程所选择的初始序号，可由TCP服务器进程随意指定，与其他报文段中的值无关==。在本题的正确选项C中，序号字段seq的值恰好与确认号字段ack的值同为11221。这正是本题迷惑大家的地方，使很多同学认为该选项有点别扭。**
  
  ****
  
  11. ![1622429765707](assets/1622429765707.png)



### 5.8.2 TCP的运输连接管理——TCP的连接释放

* 1. ![1622430573415](assets/1622430573415.png)

  * 我们来举例说明，**数据传输结束后，==TCP通信双方都可以释放连接==。现在TCP客户进程和TCP服务器进程都处于连接已建立状态。假设使用TCP客户进程的应用进程通知其主动关闭TCP连接，TCP客户进程会发送TCP连接释放报文段并进入终止等待1状态**。**该报文段首部中的终止位FIN和确认位ACK的值都被设置为1，表明这是一个==`TCP连接释放报文段`，同时也对之前收到的报文段进行确认==**。**==序号seq字段的值设置为u，它等于TCP客户进程之前已传送过的、数据的最后一个字节的序号加1==**。请注意:**TCP规定终止位FIN等于1的报文段即使不携带数据，也要消耗掉一个序号**。**确认ack字段的值设置为v，它等于TCP客户进程之前已收到的、数据的最后一个字节的序号加1**。TCP服务器进程收到TCP连接释放报文段后，会发送一个`普通的`TCP确认报文段**并进入关闭等待状态**。**该报文段首部中的确认位ACK的值被设置为1，==表明这是一个普通的TCP确认报文段==。序号seq字段的值设置为v，它等于TCP服务器进程之前已传送过的数据的最后一个字节的序号加1(==因为客户端发过来的ack为v，代表着v-1及以前的已经正确接收，现在希望收到序号为v的数据，于是服务器发送的seq=v==。)。这也与之前收到的TCP连接释放报文段中的确认号匹配。确认号ack字段的值设置为u+1(==序号为u及以前的已经正确接收，接下来期望收到序号为u+1的数据==。)，这是对TCP连接释放报文段的确认**。
  
2. ![1622430682488](assets/1622430682488.png)

* `TCP服务器进程这时应通知高层应用进程`:**TCP客户进程要断开与自己的TCP连接。此时，从TCP客户进程到TCP服务器进程这个方向的连接就释放了。==这时的TCP连接属于半关闭状态==，也就是TCP客户进程已经没有数据要发送了，但TCP服务器进程如果还有数据要发送，TCP客户进程仍要接收**。**==也就是说，从TCP服务器进程到TCP客户进程这个方向的连接并未关闭。这个状态可能会持续一段时间==**。
3. ![1622431357850](assets/1622431357850.png)

* **TCP客户进程收到TCP确认报文段后就进入终止等待2状态。==等待TCP服务器进程发出的TCP连接释放报文段==**。若使用TCP服务器进程的应用进程已经没有数据要发送了，应用进程就通知其TCP服务器进程释放连接。**由于TCP连接释放是由TCP客户进程主动发起的，因此TCP服务器进程对TCP连接的释放称为被动关闭连接**。
4. ![1622431529787](assets/1622431529787.png)

* TCP服务器进程发送TCP连接释放报文段并进入最后确认状态。**该报文段首部中的终止位FIN和确认位ACK的值都被设置为1，表明这是一个TCP连接释放报文段,同时也对之前收到的报文段进行确认**。**==现在假定序号seq字段的值为w。这是因为在半关闭状态下，TCP服务器进程可能又发送了一些数据==**。**`注意ack是不变的哦，因为客户端没有发送新数据过来`**。
  * ![1622431740246](assets/1622431740246.png)
  * **==确认号ack字段的值为u+1，这是对之前收到的TCP连接释放报文段的`重复确认`==**。
  
5. ![1622432005480](assets/1622432005480.png)

* TCP客户进程收到TCP连接释放报文段后，必须针对该报文段发送普通的TCP确认报文段，之后进入时间等待状态。**该报文段首部中的确认位ACK的值被设置为1，表明这是一个普通的TCP确认报文段。序号seq字段的值设置为u+1，这是因为TCP客户进程之前发送的TCP连接释放报文段(不普通)虽然不携带数据，但要消耗掉一个序号**。**==确认号ack字段的值设置为w+1，这是所收到的TCP连接释放报文段的确认==**。
  
6. ![1622440599066](assets/1622440599066.png)

  * **TCP服务器进程收到该报文段后就进入关闭状态。==而TCP客户进程还要经过2MSL后才能进入关闭状态==**。
  * **MSL的意思是`最长报文段寿命`，RFC793文档建议为2分钟。也就是说TCP客户进程进入时间等待状态后，还要经过4分钟才能进入关闭状态**。这完全是从工程上来考虑的。对于现在的网络，MSL取为2分钟可能太长了，因此TCP允许不同的实现可根据具体情况使用更小的MSL值。那么，TCP客户进程在发送完最后一个确认报文段后，为什么不直接进入关闭状态，而是要进去时间等待状态，2MSL后才进入关闭状态，这是否有必要呢？

  7. ![1622441099770](assets/1622441099770.png)

  * **来看这种情况，TCP服务器进程发送TCP连接释放报文段后进入最后确认状态。==TCP客户进程收到该报文段后，发送普通的TCP确认报文段，并进入关闭状态而不是时间等待状态==。`然而，该TCP确认报文段丢失了`。这必然会造成TCP服务器进程对之前发送的TCP连接释放报文段的超时重传，并仍处于最后确认状态。重传的TCP连接释放报文段到达TCP客户进程。由于TCP客户进程处于关闭状态，因此不理睬该报文段。这必然会造成TCP服务器进程反复重传TCP连接释放报文段，并一直处于最后确认状态而无法进入关闭状态。因此，时间等待状态以及处于该状态2MSL的时长，`可以确保TCP服务器进程可以收到最后一个TCP确认报文段而进入关闭状态`。另外，TCP客户进程在发送完最后一个TCP确认报文段后，再经过2MSL时长。==就可以使本次连接持续时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的TCP连接中，不会出现旧连接中的报文段==。**
  * **==就像你要和我断绝关系，然后我问你确定不，然后你他妈的一直不回应是怎么回事==**。
  * 以上就是TCP通过"四报文挥手"释放连接的过程。

*****

  8. ![1622441362845](assets/1622441362845.png)

  * **==最后，我们再来看看TCP中保活计时器的作用==**。设想这样一种情况:TCP双方已经建立了连接。**==后来，TCP客户进程所在的主机突然出现了故障，显然，TCP服务器进程以后就不能再收到TCP客户进程发来的数据==**。因此，应当有措施使TCP服务器进程不要再白白等待下去。换句话说，TCP服务器进程应该如何发现这种情况呢？方法就是使用保活计时器。TCP服务器进程每收到一次TCP客户进程的数据，就重新设置并启动保活计时器。

***

  9. ![1622441481050](assets/1622441481050.png)

### 5.9 TCP报文段的首部格式

* 1. ![1623639364993](assets/1623639364993.png)

  * 如图所示，**==TCP将应用进程交付下来的应用报文看作是字节流，存入TCP发送缓存中。==**

  2. ![1623730361435](assets/1623730361435.png)
  
  * **==TCP报文段的首部格式与IP数据报的首部格式==类似，都是由20字节的`固定首部`和最大40字节的`扩展首部`构成。我们来首先来看源端口和目的端口字段。源端口字段占16比特(2字节)，用来写入源端口号，而源端口号用来标识==发送该TCP报文段的应用进程==。目的端口字段占16比特(2字节)，用来写入目的端口号，而目的端口号用来==标识接收该TCP报文段的应用进程==。**
  * **所以一个TCP报文段首部最大60字节。**
  
  3. ![1623730554362](assets/1623730554362.png)
  
  * **我们来举例说明源端口和目的端口的作用。假设主机中的浏览器进程要访问Web服务器中的Web服务器进程。为了简单起见，我们==仅从运输层端口号这个角度==来举例说明，==而不考虑其他细节。例如ARP，域名解析，TCP连接建立等==。当在浏览器地址栏中==输入了Web服务器的域名==后，==`浏览器进程会构建一个封装有HTTP请求报文的TCP报文段`==，该报文段首部中的==源端口字段会填写一个短暂端口号，例如49152==，用来标识发送该报文段的浏览器应用进程。目的端口字段会填写==熟知端口号80(可唯一标识Web服务器上的一个进程,但现在没有给定具体标识的进程名称，于是用了广义的名称---Web服务器进程作为替代)，因为使用HTTP协议的Web服务器进程默认监听该端口==。**
  * 注意理解这句话，`浏览器进程会构建一个封装有HTTP请求报文的TCP报文段`。！！！！
  
  4. ![1623730687975](assets/1623730687975.png)
  
  * **==Web服务器==收到该TCP报文段后，==从中解封出HTTP请求报文==，并根据TCP报文段首部中目的端口字段的值80==将HTTP请求报文上交给Web服务器进程==。Web服务器进程根据HTTP请求报文的内容进行相应处理，==并构建一个HTTP响应报文==。HTTP响应报文需要封装成TCP报文段进行发送。==该报文段首部中的源端口字段会填写熟知端口号80，用来标识发送该TCP报文段的Web服务器进程。而目的端口字段会填写49152，这是主机中需要接收该TCP报文段的浏览器进程所对应的端口号==。**
  
  5. ![1623730777160](assets/1623730777160.png)
  
  * **主机收到该TCP报文段后，==从中解封出HTTP响应报文==，==并根据==TCP报文段首部中目的端口字段的值==49152==(可唯一标识主机上的一个进程，比如现在标识了浏览器进程)，==将HTTP响应报文上交给浏览器进程。==**
  
  6. ![1623730926872](assets/1623730926872.png)
  
  * **浏览器进程对HTTP响应报文的内容进行解析并显示。**
  * 我们来举例说明源端口和目的端口的作用。假设主机中的浏览器进程要访问Web服务器中的Webb服务器进程。为了简单起见，我们仅从运输层端口号这个角度来举例说明，而不考虑其他细节。例如ARP，域名解析，TCP连接建立等。当在浏览器地址栏中输入了Web服务器的域名后，浏览器进程会构建一个封装有HTTP请求报文的TCP报文段，该报文段首部中的源端口字段会填写一个短暂端口号，例如49152，用来标识发送该报文段的浏览器应用进程。目的端口字段会填写熟知端口号80，因为使用HTTP协议的Web服务器进程默认监听该端口。Web服务器收到该TCP报文段后，从中解封出HTTP请求报文，并根据TCP报文段首部中目的端口字段的值80将HTTP请求报文上交给Web服务器进程。Web服务器进程根据HTTP请求报文的内容进行相应处理，并构建一个HTTP响应报文。HTTP响应报文需要封装成TCP报文段进行发送。该报文段首部中的源端口字段会填写熟知端口号80，用来标识发送该TCP报文段的Web服务器进程。而目的端口字段会填写49152，这是主机中需要接收该TCP报文段的浏览器进程所对应的端口号。主机收到该TCP报文段后，从中解封出HTTP响应报文，并根据TCP报文段首部中目的端口字段的值49152，将HTTP响应报文上交给浏览器进程。浏览器进程对HTTP响应报文的内容进行解析并显示。
  
  ****
  ### 接下来，我呢再来看看与TCP实现可靠传输相关的序号字段、确认号字段、以及确认标志位ACK(**Acknowledge承认，答谢character**)。
  
  7. ![1623731275900](assets/1623731275900.png)
  
  * **例如，这是一个==TCP报文段，它由首部，数据载荷两部分构成==。数据载荷中的每个字节数据都有序号，如图所示。请注意:==它们是字节数据的序号而`不是内容`==。对于本例，首部中序号字段应填入的十进制值为==166，`用来指出数据载荷的第一个字节的序号为166`==。**
  * **注意：序号字段的英文名：seq**。**确认号字段的英文名：ack**。**==注意序号用完了又会回到0==**。
  
  8. ![1623731466866](assets/1623731466866.png)
  9. ![1623731579797](assets/1623731579797.png)
  
  * **==TCP规定，在连接建立后所有传送的TCP报文段都必须把ACK置1。取值为1时确认号字段(`ack`)才有效;取值为0时确认号字段无效。==**
  
  10. ![1623731884050](assets/1623731884050.png)
  
  * 我们来举例说明这三个字段的作用。**TCP客户进程发送一个TCP报文段，该报文段首部中序号字段的取值为201，这表示该TCP报文段数据载荷的第一个字节的序号为201**。假设数据载荷的长度为100字节，首部中确认号字段的取值为800，**这表示TCP客户进程收到了TCP服务器进程发来的序号到799为止的全部数据，现在期望接收到序号从800开始的数据。为了使确认号字段有效，首部中的确认标志位ACK的值必须设置为1**。
  
  11. ![1623732065114](assets/1623732065114.png)
  
  *  TCP服务器进程收到该报文段后，也给TCP客户进程发送TCP报文段。该报文段首部中序号字段的取值为800，这表示该TCP报文段数据载荷的第一个字节的序号为800，这正好与TCP客户进程的确认相匹配。
  
  12. ![1623732255064](assets/1623732255064.png)
  
  * 假设数据载荷的长度为200字节，首部中确认号字段的取值为301，这表示TCP服务器进程收到了TCP客户进程发来的序号到300为止的全部数据，现在期望收到序号从301开始的数据。
  
  13. ![1623732336413](assets/1623732336413.png)
  
  * **==为了使确认号字段有效，首部中的确认标志位ACK的值必须设置为1==。**
  
  ***
  
  14. ![1623732614243](assets/1623732614243.png)
  
  * 我们再来看数据偏移字段。
  
  15. ![1623732814437](assets/1623732814437.png)
  
  * **我们来举例说明，假设这个TCP报文段首部中的数据偏移字段的取值为二进制的0101，那么首部长度就为20字节。因为二进制的0101的十进制值是5，==而该字段以4字节为单位(作用是描述首部长度)==，因此5乘以4字节等于20字节。假设这个TCP报文段首部中的数据偏移字段的取值为二进制的1111，那么首部长度就为60字节。因为二进制的1111的十进制值是15，==而该字段以4字节为单位==，因此15乘以4字节等于60字节。**
  
  ****
  
  16. ![1623732865842](assets/1623732865842.png)
  
  *****
  
  17. ![1623733017896](assets/1623733017896.png)
  
  * **需要注意的是，==发送窗口的大小还取决于拥塞窗口的大小，也就是应该从接收窗口和拥塞窗口中取最小者==。**
  
  ***
  
  18. ![1623733192982](assets/1623733192982.png)
  
  * **用来检查整个TCP报文段在传输过程中是否出现了误码。==与UDP类似，在计算校验和时，要在TCP报文段的前面加上12字节的伪首部。具体的检验算法就不再赘述了==。因为它仅仅是一种检错算法，与TCP的其它重要功能相比，检错算法并不是重点。**
  
  ****
  
  19. ![1623733501928](assets/1623733501928.png)
  
  * **如图所示，这是我们之前课程中曾介绍过的TCP"通过三报文握手"建立连接的过程。TCP客户进程发送的TCP连接请求报文段首部中的==同步标志位SYN(同步序列编号（**Synchronize Sequence Numbers**))被置1，表明这是一个TCP==连接请求==报文段。TCP服务器进程发送的TCP连接请求确认报文段首部中的同步标志位SYN的值被置1，==确认位ACK也被置1==，表明这是一个TCP==连接==请求==确认==报文段。**
  
  * **SYN：同步序列编号（**Synchronize Sequence Numbers）。是TCP/IP建立连接时使用的握手信号。在客户机和[服务器](https://baike.baidu.com/item/服务器/100571)之间==建立正常的TCP网络连接时，客户机首先发出一个SYN消息，服务器使用SYN+ACK应答表示接收到了这个消息，最后客户机再以[ACK](https://baike.baidu.com/item/ACK/3692629)消息响应==。这样在[客户机](https://baike.baidu.com/item/客户机/5168153)和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。
  
    [TCP](https://baike.baidu.com/item/TCP/33012)连接的第一个包，非常小的一种[**数据包**](https://baike.baidu.com/item/数据包/489739)。SYN 攻击包括大量此类的包，由于这些包看上去来自实际不存在的站点，因此无法有效进行处理。每个机器的欺骗包都要花几秒钟进行尝试方可放弃提供正常响应。
  
  * [SYN_百度百科 (baidu.com)](https://baike.baidu.com/item/SYN/8880122)
  
  ****
  
  20. ![1623733581219](assets/1623733581219.png)
  
  ****
  
  21. ![1623733650133](assets/1623733650133.png)
  
  ***
  
  22. ![1623733712311](assets/1623733712311.png)
  
  ****
  
  23. ![1623733984024](assets/1623733984024.png)
  
  * 接收方收到紧急标志为1的报文段，会按照紧急指针字段的值从报文段数据载荷部分取出紧急数据，并直接上交应用进程，而不必在接收缓存中排队。
  
  ****
  
  24. ![1623734143235](assets/1623734143235.png)
  
  ****
  
  26. ![1623734244101](assets/1623734244101.png)
  
  * 如果选项的长度加上20字节固定首部的长度不能被4整除，则需要使用填充来确保首部能被4整除。
  
  *****
  
  27. ![1623734344474](assets/1623734344474.png)

## 第六章 

### 6.1 应用层概述

* 1. ![1621950391519](assets/1621950391519.png)
  2. ![1621950549170](assets/1621950549170.png)
  3. ![1621951111330](assets/1621951111330.png)

  * **例如。当我们在浏览器的地址栏中输入某个网站的域名后，就可以访问该网站的内容。这就是推动因特网飞速发展的==万维网==应用，其相关的==应用层协议为超文本传送协议HTTP==。**

  4. ![1621951161169](assets/1621951161169.png)

  * **用户在浏览器地址栏中输入的是"见名知意"的域名，而TCP/IP体系的网际层使用IP地址来标识目的主机，==从域名到IP地址的转换工作，由属于应用层范畴的域名系统DNS在后台帮用户自动完成==，以方便用户的使用。**

  5. ![1621951208189](assets/1621951208189.png)

  * **除了万维网应用和域名系统外，常见的网络应用还有动态主机配置，电子邮件，文件传送FTP和P2P文件共享，多媒体网络应用等。我们将在本章的后续课程中，分别介绍这些网络应用的相关协议和基本工作原理。**

  6. ![1621951259342](assets/1621951259342.png)

### 6.2 客户-服务器方式和对等方式

* 1. ![1621951411022](assets/1621951411022.png)
  2. ![1621952335153](assets/1621952335153.png)

  * 我们来举例说明，如图所示，**处于网络边缘的主机A中运行的是客户程序，正在运行的客户程序称为==客户进程，也可简称为客户==**。需要注意的是，**运行客户进程的主机应称为客户计算机，但有时也简称为客户。处于网络边缘的主机B中==运行的是服务器程序==，正在运行的==服务器程序称为服务器进程，也可简称为服务器==。需要注意的是，运行服务器进程的主机应称为==服务器计算机，但有时也简称为服务器==**。**在客户/服务器方式下，客户向服务器请求服务，服务器收到服务请求后向客户提供服务**。也就是说，接上图中第三点及以后。

  3. ![1621952470921](assets/1621952470921.png)

  ******

  4. ![1621952889193](assets/1621952889193.png)

  * 我们来举例说明，**如图所示，处于网络边缘的主机C,D,E,F中运行着同一种P2P程序，例如某种网络下载工具软件。E和F中的P2P进程互为对等方，C和D中的P2P进程互为对等方，而E中的P2P进程还和D中的P2P进程互为对等方。我们想象成==E中的P2P进程正在从F==下载文件，==与此同时还为D的P2P进程提供下载服务==。**

  5. ![1621952999266](assets/1621952999266.png)

  *****

  6. ![1621953041019](assets/1621953041019.png)

### 6.3 动态主机配置协议DHCP

* 1. ![1621955154068](assets/1621955154068.png)

  * 如图所示，有这样一个网络拓扑。请同学们思考一下，**我们==应该给网络中的各主机设置怎样的网络相关配置信息==，才能使他们可以正常访问网络中的Web服务器**。根据我们之前课程所介绍过的相关知识可知，**需要给网络中的各主机==正确配置IP地址==、==子网掩码==、==默认网关==、==DNS服务器等==网络相关配置信息**。例如，**这是我们给该主机手工配置的网络相关配置信息，这是我们给另一台主机手工配置的网络相关配置信息。试想一下，==如果网络中的主机数量较多，则这种手工配置的工作量就比较大，并且容易出错==。**

  2. ![1621955437954](assets/1621955437954.png)

  * **如果我们给网络中添加一台DHCP服务器，在该服务器中==设置好可为网络中其他各主机配置的网络配置信息==，网络中==各主机开机后自动启动DHCP程序==，向DHCP服务器==请求自己的网络配置信息==。这样，网络中的各主机就都可以==从DHCP服务器自动获取网络配置信息==而不用手工参与。**

  3. ![1621955489412](assets/1621955489412.png)

  * 上一张没截完整。

  4. ![1622041662538](assets/1622041662538.png)
  
  * 假设网络中有**两台DHCP服务器**和**多台用户主机**，为了简单而有效地描述DHCP的工作过程，我们**画出网络中的这两台DHCP服务器和一台用户主机**。**==DHCP使用客户/服务器方式==**，**在DHCP服务器上运行运行DHCP服务器进程，也可简称为DHCP服务器。在用户主机上运行DHCP客户进程，也可简称为DHCP客户**。DHCP是**==TCP/IP协议体系应用层中的协议==**，它**==使用运输层的`UDP`所提供的服务==**。也就是说，**DHCP报文在==运输层==会被封装成为==UDP用户数据报==**。**DHCP服务器使用的UDP端口是67**，**DHCP客户使用的UDP端口是68**，这两个**UDP端口都是熟知端口**。**封装有DHCP报文的UDP用户数据报==在网络层会被封装成IP数据报==**，**然后再根据所使用的网络接口，==封装成相应的数据链路层的帧进行发送，例如封装成以太网帧==**。为了简单起见，在后续描述过程中，除非有特别需要，否则我们将不再每次都描述DHCP报文逐层封装的过程。
  
  5. ![1622042427279](assets/1622042427279.png)
  
  * 下面，我们来看看**==DHCP客户与DHCP服务器的交互过程==**。**将主机的DHCP启动后，DHCP==客户将广播发送DHCP发现报文==，封装该报文的IP数据报的==源IP地址为0.0.0.0，这是因为主机目前还未分配到IP地址，因此使用该地址来代替==。==目的IP地址为广播地址255.255.255.255，之所以进行广播发送，是因为主机现在并不知道网络中有哪几个DHCP服务器，它们的IP地址各是什么==**。由于是**广播**的IP数据报，因此**网络中的所有设备都会收到该IP数据报**，**并对其层层解封，==解封出封装有DHCP发现报文的UDP用户数据报==**。对于DHCP客户，其应用层没有监听该UDP用户数据报的目的端口67的进程，也就是DHCP服务器进程。因此无法交付DHCP发现报文，只能丢弃。而对于DHCP服务器，其应用层始终运行着DHCP服务器进程，因此会接受该DHCP发现报文并作出响应。DHCP报文的格式比较复杂，对于DHCP发现报文，我们只需要知道，其内部封装有事物ID和DHCP客户端的MAC地址即可。DHCP服务器收到DHCP发现报文后，根据其中封装的DHCP客户端的MAC地址来查找自己的数据库，看是否有针对该MAC地址的配置信息。如果有，则使用这些配置信息来构建并发送DHCP提供报文。如果没有，则采用默认配置信息来构建并发送DHCP提供报文。封装该报文的IP数据报的源IP地址为DHCP服务器的IP地址，目的地址仍为广播地址。仍然使用广播地址的原因是:主机目前还没有配置IP地址，为了使主机可以收到，只能发送广播。这样一来，网络中的所有设备都会收到该IP数据报，并对其层层解封，解封出封装有DHCP提供报文的UDP用户数据报。对于DHCP服务器，其应用层没有监听该UDP用户数据报目的端口68的进程，也就是DHCP客户进程，因此无法交付DHCP提供报文，只能丢弃。而对于DHCP客户，其应用层运行着DHCP客户进程，因此会接受该DHCP提供报文并作出相应处理。DHCP客户会根据DHCP提供报文中的事物ID来判断该报文是否是自己所请求的报文。换句话说，如果该事物ID与自己之前发送的DHCP发现报文中封装的事物ID相等，就表明这是自己所请求的报文，就可以接受该报文，否则就丢弃该报文。DHCP提供报文中还封装有配置信息，例如IP地址、子网掩码、地址租期、默认网关、DNS服务器等。
  * 需要注意的是，**DHCP服务器从自己的IP地址池**中**==挑选待租用给主机的IP地址时,会使用ARP来确保所选IP地址未被网络中其他主机占用。==**
  
  6. ![1622042771835](assets/1622042771835.png)
  
  * 在本例中，**DHCP客户会收到两个DHCP服务器发来的DHCP提供报文，DHCP客户从中选择一个，==一般来说，选择先到的那个==**。并**==向所选择的DHCP服务器发送DHCP请求报文==，封装该报文的IP数据报的==源IP地址仍为0.0.0.0==，因为此时DHCP客户才从多个DHCP服务器中，挑选一个作为自己的DHCP服务器，==它首先需要征得该服务器的同意==，==之后才能正式使用向该DHCP服务器租用的IP地址==**。目的IP地址仍为广播地址，这样做的目的是，**==不用向网络中的每一个DHCP服务器单播发送DHCP请求报文==，来告知它们是否请求它们作为自己的DHCP服务器**。DHCP**请求报文中封装有==事物ID==，==DHCP客户端的MAC地址==，==接受的租约中的IP地址==，==提供此租约==的==DHCP服务器端的IP地址等==信息。**
  
  7. ![1622042941422](assets/1622042941422.png)
  
  * 在本例中，**==假设DHCP客户选择DHCP服务器1作为自己的DHCP服务器==**，**==并且DHCP服务器1接受该请求==**，**于是DHCP服务器1给DHCP客户发送DHCP确认报文，封装该报文的IP数据报的==源IP地址为DHCP服务器1的IP地址，目的IP地址仍为广播地址==**。**DHCP客户收到该确认报文后，就可以使用所租用到的IP地址了**。**==需要注意的是==**，**在使用租用到的IP地址之前，主机还会==使用ARP检测该IP地址是否已被网络中其他主机占用==**。若被占用，**==DHCP客户==会给DHCP服务器==发送DHCP谢绝报文来谢绝IP地址租约（已经租给别人了还想租给我？）==，并重新发送DHCP发现报文（==我要重新租另外一个==）。若未被占用，==则可以使用租约中的IP地址与网络中的其他主机通信了==。**
  
  8. ![1622043438750](assets/1622043438750.png)
  
  * **当租用期过了一半时**，DHCP客户会向DHCP服务器发送**DHCP请求报文**来**==请求更新租用期==**。封装该报文的IP数据报的**==源IP地址为DHCP客户之前租用到的IP地址==**，**==目的IP地址为DHCP服务器1的IP地址==**。
    * **DHCP服务器若同意，==则发回DHCP确认报文==**。这样，DHCP客户就得到了新的租用期。
    * **DHCP服务器若不同意，==则发回DHCP否认报文==**。这时，DHCP客户**==必须立即停止使用之前租用的IP地址==**，**并重新发送DHCP==发现报文来重新申请IP地址==**。
    * **DHCP服务器若未作出响应**，则在租用期过了87.5%时，**DHCP客户==必须重新发送DHCP请求报文==**，然后继续等待DHCP服务器**==可能==**做出的反应。**==若DHCP服务器未作出响应==**，**则==当租用期到期后==，DHCP客户==必须立即停止使用之前租用的IP地址==，并重新发送DHCP发现报文来重新申请IP地址。**
  
  9. ![1622043825961](assets/1622043825961.png)
  
  * **DHCP客户==可以随时提前终止DHCP服务器所提供的租用期==，这时==只需要向DHCP服务器==发送DHCP==释放报文段==即可**。综上所述，**这部分是DHCP客户寻找DHCP服务器，这部分是DHCP服务器向DHCP客户提供IP地址租用，这部分是DHCP客户接受IP地址租约，这部分是DHCP服务器确认IP地址租约，这部分是DHCP客户进行IP地址续约，这部分是DHCP客户可以随时解除IP地址租约。**
  * 需要注意的是，**==DHCP服务器在给DHCP客户挑选IP地址时==**，使用ARP来确保所挑选的IP地址未被网络中的其他主机占用。而**==DHCP客户在使用所租用的IP地址之前==**，也会使用ARP来检测该IP地址是否已被网络中其他主机占用。
  
  ****
  
  10. ![1622044010815](assets/1622044010815.png)
  
  * 最后，我们再来看看**DHCP中继代理**的概念。如图所示，有这样一个网络拓扑。**请大家思考一下，该网络中的各主机，是否可以通过DHCP来自动获取到网络配置信息呢？==回答是否定的==**。原因很简单，**该网络中的主机==广播发送DHCP发现报文==，但==该广播报文不会被路由器转发，而是丢弃！==**
  
  11. ![1622044156505](assets/1622044156505.png)
  
  * 解决方法是**==给该路由器配置DHCP服务器的IP地址==，并使之成为DHCP中继代理**。这样，该网络中的**各主机就可以==通过DHCP来自动获取==到网络配置信息了**。**当==该路由器收到广播的DHCP发现报文==后，会将其==单播转发给DHCP服务器==。DHCP客户和DHCP服务器通过该路由器的后续交互过程我们就不再赘述了。使用DHCP中继代理的主要原因是，我们==并不愿意在每一个网络上都设置一个DHCP服务器，因为这样会使DHCP的数量太多==。**
  
  ****
  
  12. ![1622044471972](assets/1622044471972.png)

### 6.4 域名系统DNS

* # 什么是域名？域名和ＵＲＬ有什区别？

  想要建设一个网站，必然少不了域名和服务器空间。这就好比开设商店，服务器空间就相当于商店的房间，用于存放和展示各种产品;而域名就相当于商店的地址，顾客只有知道地址，才能准确地找到店铺位置。

  域名是互联网中出现频率比较高的一个词汇。**什么是域名呢?**域名(Domain Name)是人们为了便于记忆，按照一定的规则给Internet上的计算机起的名字，通常由一串用“.”分隔的字符组成。

  域名通常由两个或两个以上的词构成，中间由小点进行分隔通俗来讲，域名的作用相当于一个家庭的门牌号码，别人通过这个号码可以很容易地找到你的位置，这也意味着在全世界没有重复的域名，域名具有唯一性。

  **虽然域名和URL相似，但是二者仍有区别**。**==域名只是一个网站的标识，不可以直接访问网站，只有当域名经过解析之后，这个域名才能成为一个URL(网址)。URL(网址)包含域名，是Internet上的地址簿，通过URL可以到达任何一个网站页面。==**

  网址和域名的关系往往容易被混淆,以为域名就是网址,实际上注册了域名并不等于就是网址。域名和网址的区别在于,**==只有当域名经过域名解析之后(也就是将域名与网站的IP地址建立对应连接关系),这个域名才可以成为一个网址==**,也就是说网址是可以直接访问网站使用的,网址不一定只是首页网址,也可以是任何一个内容页面的网址(URL)。

  ### 域名解析

  [域名](https://baike.baidu.com/item/域名)解析是把域名指向网站空间IP，让人们通过注册的域名可以方便地访问到网站的一种服务。[IP地址](https://baike.baidu.com/item/IP地址)是网络上标识站点的数字地址，为了方便记忆，采用域名来代替IP地址标识站点地址。域名解析就是域名到IP地址的转换过程。域名的解析工作由[DNS服务器](https://baike.baidu.com/item/DNS服务器)完成。

  域名解析也叫[域名指向](https://baike.baidu.com/item/域名指向/2779846)、服务器设置、域名配置以及反向IP登记等等。说得简单点就是将好记的域名解析成IP，服务由DNS服务器完成，是把域名解析到一个IP地址，然后在此IP地址的主机上将一个子目录与域名绑定。

  互联网中的地址是数字的IP地址，域名解析的作用主要就是为了便于记忆。

  在域名注册商那里注册了域名之后如何才能看到自己的网站内容，用一个专业术语就叫“域名解析”。

  域名是为了方便记忆而专门建立的一套地址转换系统，要访问一台互联网上的服务器，最终还必须通过[IP地址](https://baike.baidu.com/item/IP地址)来实现，域名解析就是将域名重新转换为IP地址的过程。一个域名对应一个IP地址，一个IP地址可以对应多个域名；所以多个域名可以同时被解析到一个IP地址。域名解析需要由专门的域名解析服务器(DNS)来完成。

  解析过程，比如，一个域名为：abc.com，是想看到这个现HTTP服务，如果要访问网站，就要进行解析，首先在[域名注册](https://baike.baidu.com/item/域名注册)商那里通过专门的[DNS服务器](https://baike.baidu.com/item/DNS服务器)解析到一个[WEB服务器](https://baike.baidu.com/item/WEB服务器)的一个固定IP上：211.214.1.XXX，然后，通过WEB服务器来接收这个域名，把abc.com这个域名映射到这台服务器上。那么，输入abc.com这个域名就可以实现访问网站内容了.即实现了域名解析的全过程；

  人们习惯记忆域名，但机器间互相只认IP地址，域名与IP地址之间是对应的，它们之间的转换工作称为域名解析，域名解析需要由专门的域名解析服务器来完成，整个过程是自动进行的。

  域名解析协议（DNS）用来把便于人们记忆的主机域名和[电子邮件地址](https://baike.baidu.com/item/电子邮件地址/2284738)映射为计算机易于识别的IP地址。DNS是一种[c/s](https://baike.baidu.com/item/c%2Fs)的结构，客户机就是用户用于查找一个名字对应的地址，而服务器通常用于为别人提供查询服务。

* 域名系统DNS是互联网使用的命名系统，用来便于把人们使用的机器名字转换为IP地址。

* 1. ![1622090619665](assets/1622090619665.png)

  * **如图所示，因特网中的某台主机要访问某台Web服务器。**

  2. ![1622090676561](assets/1622090676561.png)

  * **我们只需在用户主机中运行某个浏览器软件，在其地址栏中输入要访回的Web服务器的域名(www.hnust.cn是域名哦，不是网址哦)，并按下回车键，即可访问到Web服务器所提供的内容。这是大家最常用的一种网络应用。**

  3. ![1622090806823](assets/1622090806823.png)

  * **接下来，我们在用户主机中使用ping命令，来测试一下用户主机与Web服务器的连通性，可以看到，==我们ping的是Web服务器的域名，但ping命令实际上ping的是Web服务器的IP地址==。这与我们之前课程中所介绍的、==TCP/IP体系采用IP地址进行寻址的知识是一致的==。**
  * **也就是说，即使不使用域名==也可以通过IP地址来寻址目的主机==。==但域名与IP地址相比。便于人们记忆==。因此，对于大多数网络应用,我们==一般使用域名来访问目的主机==，而不是直接使用IP地址来访问。**

  4. ![1622090886517](assets/1622090886517.png)

  * **对于本例，简单来说，当我们在浏览器地址栏中输入某个Web服务器的域名时，==用户主机会首先`在自己的DNS高速缓存中`查找该域名所对应的IP地址==。**

  5. ![1622091006836](assets/1622091006836.png)

  * **如果==没有找到，则会向网络中的某台DNS服务器查询==。==DNS服务器中有`域名和IP地址映射关系的数据库`==。当DNS服务器==收到DNS查询报文==后，在其数据库中进行查寻，==之后将查寻结果发送给用户主机==。现在，用户主机中的浏览器可以==通过Web服务器的IP地址==对其进行访问了。**

  6. ![1622091148227](assets/1622091148227.png)

  * **请同学们思考一下，因特网是否可以只使用一台DNS服务器呢？尽管理论上可行，但在实践中这种做法并不可取。因为因特网的规模很大，==这样的域名服务器肯定会因为超负荷而无法正常工作。而且域名服务器一旦出现故障，整个因特网就会瘫痪==。**早在1983年，`分布式的域名系统DNS`。
* **DNS使大多数域名都在本地解析，仅少量解析需要在因特网上通信，因此系统效率很高。**
  * **由于DNS是`分布式系统`，即使单个计算机出了故障，也不会妨碍整个系统的正常运行。**

  *****
  
7. ![1622091328041](assets/1622091328041.png)
  8. ![1622091654318](assets/1622091654318.png)

*****

  9. ![1622091892749](assets/1622091892749.png)

*****

  10. ![1622124087974](assets/1622124087974.png)

  * **==注意，本地域名服务器可不属于上述服务器的等级结构中哦。==**

***

  11. ![1622124254280](assets/1622124254280.png)

  * 首先来看递归查询，假设图中的主机想知道域名`y.abc.com`的`IP`地址，主机首先向其本地域名服务器进行递归查询。**本地域名服务器收到递归查询的委托后。也采用递归查询的方式向某个根域名服务器查询。根域名服务器收到递归查询的委托后，也采用递归查询的方式向某个顶级域名服务器查询。顶级域名服务器收到递归查询的委托后，也采用递归查询的方式向某个权限域名服务器查询**。**==当查询到域名所对应的IP地址后，查询结果会在之前受委托的各域名服务器之间传递。最终传回给用户主机==**。
  * 所以每一次查询，结果可能是来自于`本地`(默认)域名服务器的高速缓存，也可能是来自`顶级`域名服务器，也可能是来自`权限`域名服务器。(没有根哦，根最不好记了)
  * 记忆：本地根顶级权限。本地，地下有树根，顶级权限。

  12. ![1622124613796](assets/1622124613796.png)

  * 再来看迭代查询，主机首先向其本地域名服务器进行递归查询。本地域名服务器采用迭代查询，它先向某个根域名服务器查询。**==根域名服务器`告诉本地域名服务器`，下一次应查询的顶级域名服务器的IP地址==**。**==本地域名服务器向顶级域名服务器进行迭代查询。顶级域名服务器告诉本地域名服务器，下一次应查询的权限域名服务器的IP地址。本地域名服务器向权限域名服务器进行迭代查询==**。**==权限域名服务器告诉本地域名服务器所查询的域名的IP地址。`本地域名服务器最后把查询结果告诉主机`==**。由于递归查询对于被查询的域名服务器负担太大，通常采用以下模式:从请求主机到本地域名服务器的查询是递归查询方式，而其余的查询是迭代查询方式。

*****

  13. ![1622124896007](assets/1622124896007.png)

  * **==如图所示，如果不久前已经有用户查询过域名为`y.abc.com`的IP地址，则`本地域名服务器的高速缓存中应该存有该域名应的IP地址`。当主机向本地域名服务器递归查询该域名时，本地域名服务器就没有必要再向某个根域名服务器进行迭代查询了。而是直接把高速缓存中存放的上次的查询结果，即该域名的IP地址告诉用户主机。==**

  14. ![1622125136165](assets/1622125136165.png)

  * **局部性原理的又一应用**。

*****

  15. ![1622125294226](assets/1622125294226.png)
  16. ![1622125651691](assets/1622125651691.png)

*****

  17. ![1622125785984](assets/1622125785984.png)

  * **需要注意的是，DNS报文使用运输层的UDP协议进行封装，运输层端口号为53。至于DNS报文的格式，就不再赘述了。另外，DNS污染等安全问题，已超出了本系列课程的教学大纲，有兴趣的同学可以自行查阅相关资料。**



### 6.5 文件传送协议FTP

* 1. ![1622095106740](assets/1622095106740.png)
  2. ![1622118607351](assets/1622118607351.png)

  * 如图所示，FTP采用客户/服务器方式，因特网上的FTP客户计算机，可将各种类型的文件上传到FTP服务器计算机。FTP客户计算机也可以从FTP服务器计算机下载文件。

  3. ![1622118691734](assets/1622118691734.png)

  * **根据应用需求的不同，FTP服务器可能需要一台高性能、高可靠的服务器计算机，咋可能只需要一台普通的个人计算机即可。**

  4. ![1622118857880](assets/1622118857880.png)

  * 例如，本例也可以采用普通的个人计算机作为FTP服务器计算机。为了简单起见，我们假设FTP客户计算机与FTP服务器计算机处于同一个局域网中。我们在FTP服务器计算机中创建FTP服务器（进程？）。可以使用第三方的FTP服务器软件，也可以使用操作系统自带的FTP服务器软件。例如，我们可以在Windows系统中，使用其自带的FTP服务器功能创建一个FTP服务器站点。具体方法比较简单，请同学们在网上自行查阅。假设这是我们所创建的FTP服务器的IP地址。我们可以在FTP客户计算机中，使用浏览器软件通过该地址来访问FTP服务器。需要注意的是，这是使用的是文件传输协议FTP，而不是浏览器最常使用的超文本传输协议HTTP。

  5. ![1622119132515](assets/1622119132515.png)

  * 我们也可以在FTP客户计算机中，使用windows系统自带的命令行工具，通过该地址来访问FTP服务器。例如，这是连接FTP服务器，采用匿名登录，因此无需输入密码。登录成功后，可以列出FTP服务器当然目录下的所有文件和文件夹。可以从FTP服务器下载文件，也可向FTP服务器上传文件。

  6. ![1622119196351](assets/1622119196351.png)

  * 命令行方式需要用户记住相关命令，这对普通用户而言并不友好。因此，大多数用户在FTP客户计算机上，使用第三方的FTP客户工具软件，通过友好的用户界面来完成FTP服务器的登录以及文件的上传和下载。

  7. ![1622119282595](assets/1622119282595.png)

  * FTP的常见用途是在计算机之间传输文件，尤其是用于批量传输文件。
  * FTP的另一个常见用途是让网站设计者将构成网站内容的大量文件批量上传到他们的Web服务器。

  ****

  8. ![1622122805852](assets/1622122805852.png)
  
  * 如图所示，FTP服务器监听熟知端口号21。FTP客户随机选择一个临时端口号与其建立TCP连接。这条TCP连接用于FTP客户与服务器之间传送FTP的相关控制命令。也就是说，这条TCP连接是FTP客户与服务器之间的命令通道。当有数据要传输时，FTP客户通过命令通道告知FTP服务器来与自己的另一个临时端口号建立TCP连接，即建立数据通道。这是FTP客户随机选择的另一个端口号，FTP服务器使用自己的熟知端口号20与其建立TCP连接，这条TCP连接用于FTP客户与服务器之间传送文件。也就是说，这条TCP连接是FTP客户与服务器之间的数据通道。由于在建立数据通道时，FTP服务器主动连接FTP客户，因此称为主动模式。
  * 需要注意的是：
    * 控制连接在整个会话期间一直保持打开，用于传送FTP相关控制命令。
    * 数据连接用于文件传输，在每次文件传输时才建立，传输结束就关闭。
  
  9. ![1622122997393](assets/1622122997393.png)
  
  * 再来看被动模式，对于FTP客户与服务器之间**==命令通道==**的建立，它与主动模式并没有什么不同。不同之处在于，当有数据要传输时，FTP客户通过命令通道告知FTP服务器开启某个协商好的临时端口被动等待来自FTP客户的TCP连接以建立**==数据通道==**。这是FTP服务器使用的，与FTP客户协商好的临时端口号。这是FTP客户随机选择的另一个端口号，FTP客户发起与FTP服务器的TCP连接以建立数据通道。由于在建立数据通道时，FTP服务器被动等待FTP客户的连接，因此称为被动模式。
  
  *****
  
  10. ![1622123143645](assets/1622123143645.png)
  11. ![1622123291139](assets/1622123291139.png)
  
  ***
  
  12. ![1622123355639](assets/1622123355639.png)

### 6.6电子邮件

* 1. ![1622126419823](assets/1622126419823.png)
  2. ![1622521576761](assets/1622521576761.png)
  
  * 我们来举例说明，假设这是邮件的发送方，这是邮件的接收方。在发送方的计算机中，需要使用用户代理来发送邮件。在接收方的计算机中，同样也需要使用用户代理来接收邮件。用户代理是用户与电子邮件系统的接口，又称为电子邮件客户端软件。
  * 这是发送方使用的邮件服务器，例如QQ邮件服务器。这是接收方使用的邮件服务器，例如谷歌邮件服务器。邮件服务器是电子邮件系统的基础设施。因特网上所有的ISP都有邮件服务器，其功能是发送和接收邮件，同时还要负责维护用户的邮箱。
  
  3. ![1622521803561](assets/1622521803561.png)
  
  * 如图所示，我们可以简单地认为邮件服务器中有很多邮箱、还有用来缓存待转发邮件的缓存。发送方使用用户代理通过邮件发送协议，例如SMTP将邮件发送给发送方邮件服务器。发送方邮件服务器，同样通过邮件发送协议将该邮件发送给接收方邮件服务器。接收方在方便的时候，使用用户代理，通过邮件读取协议，例如POP3，从接收方邮件服务器读取邮件。也就是说，电子邮件所需的协议包括邮件发送协议和邮件读取协议两类。
  
  4. ![1622522033025](assets/1622522033025.png)
  
  * 接下来，我们更进一步说明上述的邮件发送和接收过程。发送方的用户代理作为SMTP客户，与发送方邮件服务器中的SMTP服务器进行TCP连接,然后基于这条连接，使用SMTP协议来发送邮件给发送方邮件服务器。发送方邮件服务器中的SMTP客户，与接收方邮件服务器中的SMTP服务器进行TCP连接，然后基于这条连接，使用SMTP协议来发送已收到的待转发邮件给接收方邮件服务器。接收方的用户代理作为POP3客户，与接收方邮件服务器中的POP3服务器进行TCP连接，然后基于这条连接，使用POP3协议从接收方邮件服务器读取邮件。可以看到，这是邮件发送协议的使用范围，包含发送方用户代理到发送方邮件服务器，以及发送方邮件服务器到接收方邮件服务器这两部分。这是邮件读取协议的使用范围，只有接收方用户代理到接收方邮件服务器这一部分。
  
  ****
  
  5. 

### 6.7 万维网

* ### **说下浏览器请求一个网址的过程？**

  1.首先通过DNS服务器把域名解析成IP地址，通过IP和子网掩码判断是否属于同一个子网

  2.构造应用层请求http报文，传输层添加TCP/UDP头部，网络层添加IP头部，数据链路层添加以太网协议头部

  3.数据经过路由器、交换机转发，最终达到目标服务器，目标服务器同样解析数据，最终拿到http报文，按照对应的程序的逻辑响应回去。

  ![v2-e5f90d43a7bacc44c5337d57661c934a_720w](assets/v2-e5f90d43a7bacc44c5337d57661c934a_720w.jpg)

  * **==可将http报文用广义的应用层报文(名称)代入。==**

* 1. ![1622096754882](assets/1622096754882.png)
  2. ![1622096802521](assets/1622096802521.png)
  3. ![1622096903974](assets/1622096903974.png)

  ******

  4. ![1622097697309](assets/1622097697309.png)

  * **我们在用户主机中==使用浏览器来访问湖南科技大学的万维网服务器==，也就是访问湖南科技大学的官方网站。我们在浏览器的地址栏中，==输入==湖南科技大学官方网站的==域名==，并按下回车键后，浏览器将发送==请求报文==给服务器。服务器收到请求报文后执行相应操作，然后给浏览器发回==响应报文==。浏览器==解析并渲染==响应报文中的内容，这样我们就可以看到网站首页了。**

  ****

  5. ![1622097986136](assets/1622097986136.png)

  * **我们之前在浏览器地址栏中==输入==的是湖南科技大学官方网站的==域名==,目的是获取网站首页的内容。其对应的==统一资源定位符==如图所示。**

  6. ![1622098267331](assets/1622098267331.png)

  * **当我们点击网页中的某个超链接时，将跳转到另一个网页。可以看到，这是该网页相应的==统一资源定位符==。其中，==协议、主机和端口==与网站首页相同，不同的是路径和网页文件。**

  *****

  7. ![1622102508059](assets/1622102508059.png)

  * 这是我们之前访问的湖南科技大学官方网站的首页，我们可以将其另存为文件。可以看到有一个扩展名为html的文件和一个文件夹。

  8. ![1622102588229](assets/1622102588229.png)

  * **==我们打开该文件夹看看其内容，这三个扩展名为htm是HTML文档。这5个扩展名为js的文件是JavaScript文档。这两个扩展名为css的文件是CSS文档。其他的JPG文件和PNG文件是图片文件。==**

  *****

  9. ![1622102744652](assets/1622102744652.png)

  * 由HTML、CSS、JavaScript编写的万维网文档。由浏览器内核负责解析和渲染。
  
  10. ![1622116522294](assets/1622116522294.png)
  
  * 这是用HTML编写的最简单的HTML文档，用浏览器打开该HTML文档，可以看到浏览器渲染出了一个非常简单的网页。在HTML文档中，使用两个html标签来定义HTML文档的范围。在其内部使用两个head标签定义HTML文档的首部,使用两个body标签定义HTML文档的主体，首部中两个title标签之间的内容被渲染为网页的标题。两个p标签之间的内容被渲染为一个文本段落。通过本例可以看出HTML使用多种“标签”来描述网页的结构和内容。但是，所呈现出来的内容样式过于简单，或者说不够美观。我们可以在CSS文档中定义一些所需的样式对网页显示内容进行美化。
  
  11. ![1622116751103](assets/1622116751103.png)
  
  * 例如，我们编写了这样一个CSS文档。在其中定义了一种样式:即颜色为深粉色，字体大小为36个像素。然后，我们在之前编写好的HTML文档的首部使用link标签将该CSS文档引入。将样式名称指定给主体中需要更改样式的那个p标签。现在，我们在浏览器中进行刷新，
  
  12. ![1622116859077](assets/1622116859077.png)
  
  * 就可以看到浏览器重新渲染出了网页内容。可以看到，Hello world段落的颜色和字体大小都发生了相应的变化。
  
  13. ![1622117301926](assets/1622117301926.png)
  
  * 接下来，我们再给该网页添加一个按钮。在之前的HTML文档的主体中，使用button标签来添加一个按钮。我们为该按钮指定一个发生单击事件时应该调用的处理函数，然后用JavaScript脚本语言来编写一个JS文档。在该文档中编写单机事件处理函数的具体实现代码。在HTML文档的首部使用script标签将该JS文档引入。
  
  14. ![1622117350688](assets/1622117350688.png)
  
  * 在事件处理函数中，通过元素的id来找到相应的函数，也就是显示Hello world的p标签，然后更改其显示内容。
  
  15. ![1622117387115](assets/1622117387115.png)
  
  * 现在，我们在浏览器中进行刷新，就可以看到我们所添加的按钮。
  
  16. ![1622117414357](assets/1622117414357.png)
  
  * 当我们用鼠标点击该按钮时，Hello world变成了谢谢你的赞。
  * 通过上述举例，相信同学们对HTML文档，CSS文档，JavaSaript文档已经有了初步的认识。至于这些文档的具体编写，属于Web前端开发的基础，并不属于本课程的教学大纲，我们就不再深入介绍了。需要大家注意的是，这些文档都部署在服务器端，有一些是Web前端开发人员设计好的静态页面，有一些是服务器后端程序根据用户需求自动生成的动态页面。它们都需要从服务器传送给用户浏览器进行解析和渲染。这就不得不提到TCP/IP体系应用层中的一个非常重要的协议:即超文本传输协议HTTP。
  
  ****
  
  ****
  
  ****
  
  1. ![1622118198727](assets/1622118198727.png)
  
  * 我们来举例说明，我们使用用户主机来访问湖南科技大学的万维网服务器,可以看成是用户主机中的浏览器进程，即客户进程与服务器中的服务器进程基于因特网的通信。**`浏览器进程首先发起与服务器进程的TCP连接`，==使用熟知端口号80==。==`基于这条已建立好的TCP连接`==，==浏览器进程向服务器进程发送HTTP请求报文，服务器进程收到后，执行相应操作，然后给浏览器进程发回HTTP响应报文==。**
  
  2. ![1622468463196](assets/1622468463196.png)
  
  * 我们来举例说明，这是客户与服务器之间通过三报文握手进行TCP连接。**==在这三个报文中的最后一个报文的数据载荷部分，携带有`HTTP`请求报文==**。服务器收到后给客户发回HTTP响应报文。这是一次请求和响应所耗费的时间，记为往返时间RTT。这又是一次请求和响应所耗费的时间RTT。这是文档的传输时延。**==可以看到，请求一个万维网文档所需的时间为2RTT(RTT假设取等)+文档的传输时延==**。
  
  3. ![1622468704878](assets/1622468704878.png)
  
  * **http/1.1主要是通过`持续连接`减少了TCP多次连接所浪费的时间。**
  
  ****
  
  1. ![1622469240939](assets/1622469240939.png)
  
  * 首先来看HTTP请求报文的格式，我们用很窄的小格子表示空格，用标有`CRLF`的格子表示回车换行。`HTTP`请求报文的**==第一行是请求行==**。**由==方法==字段开始，其后跟一个==空格==，后跟==统一资源定位符(准确的来说是URI而不是URL)==字段，其后跟一个==空格==，后跟==版本==字段，最后是==回车换行。(共6个东西)==**。**从第二行开始，就是==首部行==**，每一个首部行由**首部字段名**开始，其后跟一个**冒号**，再跟一个**空格**，**然后是该字段的取值**，**最后是回车换行**。**==可以有多个首部行==**，如图所示。**==在最后的首部行下面是一个空行==。在空行下面是实体主体，通常不使用。**
  
  2. ![1622469833659](assets/1622469833659.png)
  
  * 我们来举例说明HTTP请求报文的格式。这是浏览器发送的HTTP请求报文的具体内容。**第一行为`请求行`。指明了`方法GET`，统一`资源定位符`，以及`HTTP的版本`。**
  * 这是第一个首部行，**首部字段名为`Host`**，**其==值为湖南科技大学官方网站的域名==**。这是第二个首部行，**首部字段名为`Connection`**，其**==值为Close==**，**==这是告诉服务器发送完请求的文档后就可以释放连接==**。这是第三个首部行，**首部字段名为`User-Agent`**，其**==值是浏览器的类型及版本==**。这是第四个首部行，**首部字段名为`Accept-Language`**，**==其值是cn==**，**这是告诉服务器用户希望优先得到中文版本的文档**。**==在最后一个首部行的下面是一个空行==。该HTTP请求报文没有实体主体。**
  * ==**所以我们可以初步的总结出几个常用`首部字段名` 和 `该字段名对应的取值` 及 `该取值的含义`。**==
    * `Host`:**取值为某网站的域名**。
    * `Connection`:取值为`Close`或`Open`，含义是告诉服务器发送完请求的文档后是释放还是保持连接
    * `User-Agent`:取值是浏览器的**类型**及**版本**。用户的代理(小秘)嘛，当然是浏览器了。
    * `Accept-Language`:其值是`cn`，**这是告诉服务器用==户希望优先得到中文版本的文档==**
  
  3. ![1622469952144](assets/1622469952144.png)
  
  ****
  
  4. ![1622470190010](assets/1622470190010.png)
  
  * 再来看HTTP响应报文的格式。HTTP**==响应报文(请求报文)==**的第一行是**==状态行(请求行)==**。由**==[http的]版本(方法)==**字段开始，其后跟一个**==空格==**，后跟**==状态码(url)==**字段，其后跟一个**==空格==**，后跟**==短语字段(http版本)==**，最后是**==回车换行。(也是共6个东西，两个空格，一个回车换行是其共有的)==**。除状态行外，HTTP响应报文的其他部分与HTTP请求报文格式的对应部分是相似的。我们就不再赘述了。
  
  5. ![1622470279510](assets/1622470279510.png)
  
  6. ![1622470935863](assets/1622470935863.png)
  
  * **HTTP/1.1表示版本，202是状态码，==Accepted是短语，也就是对状态码的简单描述==。**
  
  7. ![1622470990886](assets/1622470990886.png)
  
  * **一般来说，浏览器并不会直接显示出服务器发送来的这些状态行信息。==而是以更友好的形式向用户告知服务器所返回的状态信息。==**
  * **例如，当我们访问某些网站时，浏览器可能会显示类似该图所示的提示信息。==其背后的本质是浏览器收到了包含这条状态行的响应报文。==**
  
  ****
  
  8. ![1622471174213](assets/1622471174213.png)
  
  * **在我们访问网站时，浏览器通常会使用Cookie在服务器上记录用户信息。**
  * **例如，我们使用浏览器在某个网站上已经注册了自己的账号。当在该网站登录自己的账号时，除了输入用户名和密码外，我们还可以选择"记住我"选项。这样，当我们下一次使用该浏览器再次访问该网站时，网站可以自动识别出我们，而不用我们再次输入账号信息。**
  
  9. ![1622471266000](assets/1622471266000.png)
  10. ![1622472607561](assets/1622472607561.png)
  
  * 我们来举例说明Cookie的工作原理，**用户主机中的浏览器进程首先与万维网服务器中的服务器进程建立TCP连接，==当用户的浏览器进程初次向服务器进程发送HTTP请求报文时，`服务器进程`就会`为其产生`一个唯一的Cookie识别码,`并以此为索引在服务器的后端数据库中创建一个项目`,`用来记录该用户访问该网站的各种信息`==**。**==接着就会给浏览器进程发回HTTP响应报文，在响应报文中，包含有一个首部字段为Set-Cookie的首部行，该字段的取值就是Cookie识别码==**。**==`当浏览器进程`收到该响应报文后，就`在一个特定的Cookie文件中添加一行`，`记录该服务器的域名和Cookie的识别码`。当用户再次使用该浏览器访问这个网站时，每发送一个HTTP请求报文。`浏览器器都会从Cookie文件中取出`该网站的Cookie识别码，`并放到HTTP请求报文的Cookie首部行中`。`服务器根据Cookie识别码就可以识别出该用户，并返回该用户的个性化网页`==**。
  * **==这个记住我实际上不是记住的账号密码，而是cookie==**。
  
  ****
  
  11. ![1622473889594](assets/1622473889594.png)
  
  * **万维网缓存又称Web缓存，可位于客户机(访问过的信息存到本地)，==也可位于中间系统上，位于中间系统上的Web缓存又称代理服务器==。**
  * 我们来举例说明，假设这是因特网上的某台万维网服务器，为了与万维网代理服务器的名称区分，我们简称该服务器为原始服务器。这是校园网中的某台万维网代理服务器，我们简称其为代理服务器。**==当校园网中的某台主机要访问因特网上的原始服务器时，它首先会向校园网中的代理服务器发送请求，若代理服务器中存放有所请求的对象，则代理服务器会向该主机发回包含所请求对象的响应==**。
  
  12. ![1622510989587](assets/1622510989587.png)
  
  * **==若代理服务器中没有所请求的对象，则代理服务器会向因特网上的原始服务器发送请求，原始服务器将包含有所请求对象的响应发回给代理服务器，代理服务器将该响应存入Web缓存，然后给主机发回该响应。==**
  
  13. ![1622511078873](assets/1622511078873.png)
  
  * **可以想象，==如果Web缓存的命中率比较高，则路由器R1和R2之间的链路上的通信量将大大减少==，因而可以减少校园网各主机访问因特网的时延**。
  
  *****
  
  14. ![1622511230293](assets/1622511230293.png)
  
  * **有的同学可能会有这样的疑问。这是原始服务器中的某个文档，这是该文档在代理服务器中的副本。==假设原始服务器中的该文档已被更改。之后，校园网中的某台主机要请求该文档，它首先向校园网中的代理服务器发送请求，代理服务器找到该文档后，将其封装在响应报文中发回给主机。这样，主机所请求到的文档与原始服务器中的文档就不一致了。==**
  
  15. ![1622511373440](assets/1622511373440.png)
  
  * **实际上，原始服务器通常==会为每个响应的对象设定一个`修改时间字段`，和一个`有效日期字段`==。当校园网中的某台主机要请求原始服务器中的该文档时，它首先向校园网中的代理服务器发送请求，==若代理服务器中的该文档未过期==，则代理服务器将其封装在响应报文中发回给主机。**
  
  16. ![1622511552874](assets/1622511552874.png)
  
  * **若代理服务器中的该文档已过期**，则代理服务器会向因特网上的原始服务器发送请求，==在请求报文中包含有一个首部字段为`If-modified-since`的首部行，该字段的取值就是该文档的修改日期==**。原始服务器根据该文档的修改日期，就可判断出代理服务器中存储的该文档是否与自己存储的该文档一致**。**如果一致，则给代理服务器发送==不包含实体主体(无消息体)==的响应，状态码为304，短语为`Not Modified`**。**代理服务器重新更新该文档的有效日期。(那个Expires是从已过期又变为了Expires)。然后将该文档封装在响应报文中发回给主机。**
  
  17. ![1622511720532](assets/1622511720532.png)
  
  * **如果不一致，则给代理服务器发送封装有该文档的响应报文**，如图所示。
  
  18. ![1622511834326](assets/1622511834326.png)
  
  * **这样代理服务器就更新了该文档，然后将更新后的该文档封装在响应报文中发回给主机。**
  
  ****
  
  1. ![1622512001715](assets/1622512001715.png)
  2. ![1622512180644](assets/1622512180644.png)
  
  *****
  
  3. ![1622512310778](assets/1622512310778.png)





  







